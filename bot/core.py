"""
üéì Telegram Bot Core - Main Bot Implementation
"""
import asyncio
from datetime import datetime, timedelta, timezone
from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.constants import ParseMode
from telegram.ext import (
    Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters,
    ContextTypes, ConversationHandler
)
from typing import Dict, List
import re
import os

from config import CONFIG
from storage.models import DatabaseManager
from storage.user_storage_v2 import UserStorageV2
from storage.grade_storage_v2 import GradeStorageV2
from admin.dashboard import AdminDashboard
from admin.broadcast import BroadcastSystem
from utils.keyboards import (
    get_main_keyboard, get_admin_keyboard, get_cancel_keyboard, 
    get_unregistered_keyboard,
    remove_keyboard, get_error_recovery_keyboard, get_settings_main_keyboard
)
from utils.messages import get_welcome_message, get_help_message, get_simple_welcome_message, get_security_welcome_message, get_credentials_security_info_message
from security.enhancements import security_manager, is_valid_length
from security.headers import security_headers, security_policy
from utils.analytics import GradeAnalytics
from university.api_client_v2 import UniversityAPIV2
from utils.logger import get_bot_logger

# Get bot logger
logger = get_bot_logger()
ASK_USERNAME, ASK_PASSWORD = range(2)

class TelegramBot:
    """Main Telegram Bot Class"""
    
    def __init__(self):
        self.app, self.db_manager, self.user_storage, self.grade_storage = None, None, None, None
        self.university_api = UniversityAPIV2()
        # Initialize storage before other components
        self._initialize_storage() 
        # Initialize components that depend on storage
        self.grade_analytics = GradeAnalytics(self.user_storage)
        self.admin_dashboard = AdminDashboard(self)
        self.broadcast_system = BroadcastSystem(self)
        self.grade_check_task = None
        self.running = False

    def _initialize_storage(self):
        pg_initialized = False
        # Initialize new clean storage systems
        try:
            logger.info("üóÑÔ∏è Initializing new clean storage systems...")
            self.user_storage = UserStorageV2(CONFIG["DATABASE_URL"])
            self.grade_storage = GradeStorageV2(CONFIG["DATABASE_URL"])
            logger.info("‚úÖ New storage systems initialized successfully.")
        except Exception as e:
            logger.critical(f"‚ùå FATAL: Storage initialization failed. Bot cannot run: {e}", exc_info=True)
            raise RuntimeError("Failed to initialize storage systems.")

    async def start(self):
        self.running = True
        self.app = Application.builder().token(CONFIG["TELEGRAM_TOKEN"]).build()
        await self._update_bot_info()
        self._add_handlers()
        self.grade_check_task = asyncio.create_task(self._grade_checking_loop())
        self.daily_quote_task = asyncio.create_task(self.scheduled_daily_quote_broadcast())
        await self.app.initialize()
        await self.app.start()
        port = int(os.environ.get("PORT", 8443))
        
        # Try to get Railway URL from environment
        railway_app_name = os.getenv("RAILWAY_APP_NAME")
        
        # Use WEBHOOK_URL if it's a full URL
        webhook_url_env = os.getenv("WEBHOOK_URL")
        if webhook_url_env and webhook_url_env.startswith("https://"):
            # Use the provided webhook URL
            webhook_url = webhook_url_env
            railway_url = webhook_url_env.replace(f"/{CONFIG['TELEGRAM_TOKEN']}", "")
        else:
            # Build webhook URL from Railway domain
            railway_url = (
                webhook_url_env or 
                os.getenv("RAILWAY_STATIC_URL") or 
                os.getenv("RAILWAY_PUBLIC_DOMAIN") or
                os.getenv("RAILWAY_DOMAIN") or
                (f"{railway_app_name}.up.railway.app" if railway_app_name else None) or
                "your-app-name.up.railway.app"  # fallback if nothing else is set
            )
            
            # Final webhook URL
            webhook_url = f"https://{railway_url}/{CONFIG['TELEGRAM_TOKEN']}"
        
        logger.info(f"üåê Webhook URL: {webhook_url}")
        logger.info(f"üîß Railway URL source: {railway_url}")
        
        await self.app.updater.start_webhook(listen="0.0.0.0", port=port, url_path=CONFIG["TELEGRAM_TOKEN"], webhook_url=webhook_url)
        logger.info(f"‚úÖ Bot started on webhook: {webhook_url}")

    async def _update_bot_info(self):
        try:
            # Only update bot name/description if needed
            current_name = await self.app.bot.get_my_name()
            if current_name.name != CONFIG["BOT_NAME"]:
                try:
                    await self.app.bot.set_my_name(CONFIG["BOT_NAME"])
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Failed to set bot name: {e}")
            current_desc = await self.app.bot.get_my_description()
            if current_desc.description != CONFIG["BOT_DESCRIPTION"]:
                try:
                    await self.app.bot.set_my_description(CONFIG["BOT_DESCRIPTION"])
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Failed to set bot description: {e}")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Failed to update bot info: {e}")

    async def stop(self):
        self.running = False
        if self.grade_check_task:
            self.grade_check_task.cancel()
        if hasattr(self, 'daily_quote_task') and self.daily_quote_task:
            self.daily_quote_task.cancel()
        if self.app: await self.app.shutdown()
        logger.info("üõë Bot stopped.")

    def _add_handlers(self):
        # Register all bot handlers
        registration_handler = ConversationHandler(
            entry_points=[
                CommandHandler("register", self._register_start),
                MessageHandler(filters.Regex("^üöÄ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÑŸÑÿ¨ÿßŸÖÿπÿ©$"), self._register_start)
            ],
            states={ASK_USERNAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, self._register_username)], ASK_PASSWORD: [MessageHandler(filters.TEXT & ~filters.COMMAND, self._register_password)]},
            fallbacks=[CommandHandler("cancel", self._cancel_registration), MessageHandler(filters.Regex("^‚ùå ÿ•ŸÑÿ∫ÿßÿ°$"), self._cancel_registration)],
        )
        self.app.add_handler(registration_handler)
        self.app.add_handler(self.broadcast_system.get_conversation_handler())
        self.app.add_handler(CommandHandler("start", self._start_command))
        self.app.add_handler(CommandHandler("help", self._help_command))
        self.app.add_handler(CommandHandler("grades", self._grades_command))
        self.app.add_handler(CommandHandler("old_grades", self._old_grades_command))
        self.app.add_handler(CommandHandler("profile", self._profile_command))
        self.app.add_handler(CommandHandler("settings", self._settings_command))
        self.app.add_handler(CommandHandler("support", self._support_command))
        # Security-related commands
        self.app.add_handler(CommandHandler("security_info", self._security_info_command))
        self.app.add_handler(CommandHandler("security_audit", self._security_audit_command))
        self.app.add_handler(CommandHandler("privacy_policy", self._privacy_policy_command))
        self.app.add_handler(CommandHandler("security_stats", self._security_stats_command))
        self.app.add_handler(CommandHandler("security_headers", self._security_headers_command))
        # Admin panel command
        self.app.add_handler(CommandHandler("admin", self._admin_command))
        self.app.add_handler(CommandHandler("notify_grades", self._admin_notify_grades))
        self.app.add_handler(CallbackQueryHandler(self._handle_callback))
        self.app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self._handle_message))
        self.app.add_handler(CallbackQueryHandler(self._settings_callback_handler, pattern="^(back_to_main|cancel_action)$"))

    async def _send_message_with_keyboard(self, update, message, keyboard_type="main"):
        keyboards = {
            "main": get_main_keyboard, 
            "admin": get_admin_keyboard, 
            "cancel": get_cancel_keyboard, 
            "unregistered": get_unregistered_keyboard,
            "error_recovery": get_error_recovery_keyboard
        }
        await update.message.reply_text(message, reply_markup=keyboards.get(keyboard_type, get_main_keyboard)())
    
    async def _send_message_without_keyboard(self, update, message):
        """Send message and remove any existing keyboard."""
        await update.message.reply_text(message, reply_markup=remove_keyboard())
    
    async def _edit_message_no_keyboard(self, message_obj, new_text):
        try: await message_obj.edit_text(new_text)
        except Exception: pass 

    async def _start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user = self.user_storage.get_user(update.effective_user.id)
        fullname = user.get('fullname') if user else None
        
        # Show user-friendly welcome message
        if user:
            # Registered user - show simple welcome with security info
            welcome_message = get_security_welcome_message()
            await self._send_message_with_keyboard(update, welcome_message, "main")
        else:
            # New user - show simple explanation
            welcome_message = get_simple_welcome_message()
            await self._send_message_with_keyboard(update, welcome_message, "unregistered")

    async def _help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        is_admin = user_id == CONFIG["ADMIN_ID"]
        help_text = (
            "üéì ÿØŸÑŸäŸÑ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ®Ÿàÿ™\n\n"
            "ŸÉŸäŸÅŸäÿ© ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ:\n"
            "1. ÿßÿ∂ÿ∫ÿ∑ 'üöÄ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ' Ÿàÿ£ÿØÿÆŸÑ ÿ®ŸäÿßŸÜÿßÿ™ŸÉ ÿßŸÑÿ¨ÿßŸÖÿπŸäÿ©\n"
            "2. ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ£ÿ≤ÿ±ÿßÿ± ŸÑŸÅÿ≠ÿµ ÿßŸÑÿØÿ±ÿ¨ÿßÿ™ ŸàÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™\n"
            "3. ŸÑŸÑŸÖÿ≥ÿßÿπÿØÿ© ÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑŸÖÿ∑Ÿàÿ±\n\n"
            "ÿßŸÑÿ£ŸàÿßŸÖÿ± ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ©:\n"
            "/start - ÿ®ÿØÿ° ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ\n"
            "/help - ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ©\n"
            "/grades - ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿØÿ±ÿ¨ÿßÿ™ ÿßŸÑŸÅÿµŸÑ ÿßŸÑÿ≠ÿßŸÑŸä\n"
            "/old_grades - ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿØÿ±ÿ¨ÿßÿ™ ÿßŸÑŸÅÿµŸÑ ÿßŸÑÿ≥ÿßÿ®ŸÇ\n"
            "/profile - ŸÖÿπŸÑŸàŸÖÿßÿ™Ÿä\n"
            "/settings - ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™\n"
            "/support - ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä\n\n"
            "ÿ£ŸàÿßŸÖÿ± ÿßŸÑÿ£ŸÖÿßŸÜ:\n"
            "/security_info - ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ£ŸÖÿßŸÜ\n"
            "/security_audit - ÿ™ŸÇÿ±Ÿäÿ± ÿßŸÑÿ™ÿØŸÇŸäŸÇ ÿßŸÑÿ£ŸÖŸÜŸä\n"
            "/security_headers - ŸÖÿπŸÑŸàŸÖÿßÿ™ ŸÖÿπÿßŸäŸäÿ± ÿßŸÑÿ£ŸÖÿßŸÜ (ŸÑŸÑŸÖÿ∑Ÿàÿ± ŸÅŸÇÿ∑)\n"
            "/privacy_policy - ÿ≥Ÿäÿßÿ≥ÿ© ÿßŸÑÿÆÿµŸàÿµŸäÿ©\n"
        )
        if is_admin:
            help_text += "\nÿ£ŸàÿßŸÖÿ± ÿßŸÑŸÖÿØŸäÿ±:\n/security_stats - ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ£ŸÖÿßŸÜ\n/admin - ŸÑŸàÿ≠ÿ© ÿßŸÑÿ™ÿ≠ŸÉŸÖ\n"
        help_text += f"\nüë®‚Äçüíª ÿßŸÑŸÖÿ∑Ÿàÿ±: {CONFIG.get('ADMIN_USERNAME', '@admin')}"
        try:
            # Send help as plain text
            await update.message.reply_text(help_text)
        except Exception as e:
            logger.error(f"Error sending help message: {e}")

    async def _security_info_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            from admin.dashboard import AdminDashboard
            security_info = AdminDashboard.get_user_security_info()
            await update.message.reply_text(security_info, reply_markup=get_main_keyboard())
        except Exception as e:
            await update.message.reply_text("ÿπÿ∞ÿ±ÿßŸãÿå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿπÿ±ÿ∂ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ£ŸÖÿßŸÜ.", reply_markup=get_main_keyboard())
            logger.error(f"Error in _security_info_command: {e}", exc_info=True)

    async def _security_audit_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            audit_message = (
                "üìã ÿ™ŸÇÿ±Ÿäÿ± ÿßŸÑÿ™ÿØŸÇŸäŸÇ ÿßŸÑÿ£ŸÖŸÜŸä:\n\n"
                "‚Ä¢ ÿ¨ŸÖŸäÿπ ÿßŸÑÿπŸÖŸÑŸäÿßÿ™ ŸÅŸä ÿßŸÑÿ®Ÿàÿ™ ÿ™ÿÆÿ∂ÿπ ŸÑŸÖÿ±ÿßÿ¨ÿπÿ© ÿØŸàÿ±Ÿäÿ© ŸÑÿ∂ŸÖÿßŸÜ ÿßŸÑÿ£ŸÖÿßŸÜ.\n"
                "‚Ä¢ ŸÑÿß Ÿäÿ™ŸÖ ÿ™ÿÆÿ≤ŸäŸÜ ŸÉŸÑŸÖÿßÿ™ ÿßŸÑŸÖÿ±Ÿàÿ± ÿ£Ÿà ŸÖÿ¥ÿßÿ±ŸÉÿ™Ÿáÿß ŸÖÿπ ÿ£Ÿä ÿ¨Ÿáÿ©.\n"
                "‚Ä¢ ŸÜÿ≥ÿ™ÿÆÿØŸÖ ÿ£ÿ≠ÿØÿ´ ŸÖÿπÿßŸäŸäÿ± ÿßŸÑÿ£ŸÖÿßŸÜ ŸÑÿ≠ŸÖÿßŸäÿ© ÿ®ŸäÿßŸÜÿßÿ™ŸÉ.\n\n"
                "ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÑÿØŸäŸÉ ÿ£Ÿä ÿ≥ÿ§ÿßŸÑ ÿπŸÜ ÿßŸÑÿ£ŸÖÿßŸÜÿå ÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä."
            )
            await update.message.reply_text(audit_message, reply_markup=get_main_keyboard())
        except Exception as e:
            await update.message.reply_text("ÿπÿ∞ÿ±ÿßŸãÿå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿπÿ±ÿ∂ ÿ™ŸÇÿ±Ÿäÿ± ÿßŸÑÿ™ÿØŸÇŸäŸÇ.", reply_markup=get_main_keyboard())
            logger.error(f"Error in _security_audit_command: {e}", exc_info=True)

    async def _privacy_policy_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            privacy_message = (
                "üîí ÿ≥Ÿäÿßÿ≥ÿ© ÿßŸÑÿÆÿµŸàÿµŸäÿ©:\n\n"
                "‚Ä¢ ÿ®ŸäÿßŸÜÿßÿ™ŸÉ ÿßŸÑÿ¨ÿßŸÖÿπŸäÿ© ÿ™Ÿèÿ≥ÿ™ÿÆÿØŸÖ ŸÅŸÇÿ∑ ŸÑÿ¨ŸÑÿ® ÿßŸÑÿØÿ±ÿ¨ÿßÿ™ ŸàŸÑÿß Ÿäÿ™ŸÖ ÿ™ÿÆÿ≤ŸäŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ŸÜŸáÿßÿ¶ŸäÿßŸã.\n"
                "‚Ä¢ ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™ ŸÖÿ¥ŸÅÿ±ÿ© Ÿàÿ¢ŸÖŸÜÿ© ŸàŸÑÿß Ÿäÿ™ŸÖ ŸÖÿ¥ÿßÿ±ŸÉÿ™Ÿáÿß ŸÖÿπ ÿ£Ÿä ÿ¨Ÿáÿ© ÿÆÿßÿ±ÿ¨Ÿäÿ©.\n"
                "‚Ä¢ ŸäŸÖŸÉŸÜŸÉ ÿ≠ÿ∞ŸÅ ÿ®ŸäÿßŸÜÿßÿ™ŸÉ ŸÅŸä ÿ£Ÿä ŸàŸÇÿ™ ŸÖŸÜ ÿÆŸÑÿßŸÑ ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä.\n"
                "‚Ä¢ ŸáÿØŸÅŸÜÿß ŸáŸà ÿ≠ŸÖÿßŸäÿ© ÿÆÿµŸàÿµŸäÿ™ŸÉ Ÿàÿ™ŸÇÿØŸäŸÖ ÿ£ŸÅÿ∂ŸÑ ÿ™ÿ¨ÿ±ÿ®ÿ© ŸÖŸÖŸÉŸÜÿ©.\n\n"
                "ŸÑÿ£Ÿä ÿßÿ≥ÿ™ŸÅÿ≥ÿßÿ± ÿπŸÜ ÿßŸÑÿÆÿµŸàÿµŸäÿ©ÿå ÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä."
            )
            await update.message.reply_text(privacy_message, reply_markup=get_main_keyboard())
        except Exception as e:
            await update.message.reply_text("ÿπÿ∞ÿ±ÿßŸãÿå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿπÿ±ÿ∂ ÿ≥Ÿäÿßÿ≥ÿ© ÿßŸÑÿÆÿµŸàÿµŸäÿ©.", reply_markup=get_main_keyboard())
            logger.error(f"Error in _privacy_policy_command: {e}", exc_info=True)

    async def _security_stats_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            if update.effective_user.id != CONFIG["ADMIN_ID"]:
                await update.message.reply_text("üö´ Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÖÿ™ÿßÿ≠ ŸÑŸÑŸÖÿØŸäÿ± ŸÅŸÇÿ∑.", reply_markup=get_main_keyboard())
                return
            stats = security_manager.get_security_stats()
            
            # Support both old and new stats structures
            total_events = stats.get('total_events_24h', 0)
            failed_logins = stats.get('failed_logins', 0)
            blocked_attempts = stats.get('blocked_attempts', 0)
            active_sessions = stats.get('active_sessions', 0)
            high_risk_events = stats.get('high_risk_events', 0)
            
            # Extract nested stats if present
            if 'rate_limiter' in stats:
                blocked_attempts = stats.get('rate_limiter', {}).get('blocked_users', 0)
            if 'session_manager' in stats:
                active_sessions = stats.get('session_manager', {}).get('active_sessions', 0)
            
            stats_message = (
                "üîê ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ£ŸÖÿßŸÜ (24 ÿ≥ÿßÿπÿ©)\n\n"
                f"üìä ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑÿ£ÿ≠ÿØÿßÿ´: {total_events}\n"
                f"‚ùå ŸÖÿ≠ÿßŸàŸÑÿßÿ™ ÿ™ÿ≥ÿ¨ŸäŸÑ ŸÅÿßÿ¥ŸÑÿ©: {failed_logins}\n"
                f"üö´ ŸÖÿ≠ÿßŸàŸÑÿßÿ™ ŸÖÿ≠ÿ∏Ÿàÿ±ÿ©: {blocked_attempts}\n"
                f"üë• ÿßŸÑÿ¨ŸÑÿ≥ÿßÿ™ ÿßŸÑŸÜÿ¥ÿ∑ÿ©: {active_sessions}\n"
                f"‚ö†Ô∏è ÿ£ÿ≠ÿØÿßÿ´ ÿπÿßŸÑŸäÿ© ÿßŸÑÿÆÿ∑Ÿàÿ±ÿ©: {high_risk_events}\n\n"
                "üí° Ÿáÿ∞Ÿá ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿ™ÿ≥ÿßÿπÿØ ŸÅŸä ŸÖÿ±ÿßŸÇÿ®ÿ© ÿßŸÑÿ£ŸÖÿßŸÜ"
            )
            await update.message.reply_text(stats_message, reply_markup=get_main_keyboard())
        except Exception as e:
            await update.message.reply_text("ÿπÿ∞ÿ±ÿßŸãÿå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ¨ŸÑÿ® ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ£ŸÖÿßŸÜ.", reply_markup=get_main_keyboard())
            logger.error(f"Error in _security_stats_command: {e}", exc_info=True)

    async def _security_headers_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            headers_message = (
                "üõ°Ô∏è ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ£ŸÖÿßŸÜ:\n\n"
                "‚Ä¢ ÿßŸÑÿ®Ÿàÿ™ Ÿäÿ≥ÿ™ÿÆÿØŸÖ ÿ™ŸÇŸÜŸäÿßÿ™ ÿ≠ŸÖÿßŸäÿ© ŸÖÿ™ŸÇÿØŸÖÿ© ŸÑÿ∂ŸÖÿßŸÜ ÿ≥ÿ±Ÿäÿ© ÿ®ŸäÿßŸÜÿßÿ™ŸÉ.\n"
                "‚Ä¢ ÿ¨ŸÖŸäÿπ ÿßŸÑÿßÿ™ÿµÿßŸÑÿßÿ™ ŸÖÿ¥ŸÅÿ±ÿ© Ÿàÿ¢ŸÖŸÜÿ©.\n"
                "‚Ä¢ ŸÑÿß ÿØÿßÿπŸä ŸÑŸÑŸÇŸÑŸÇ ÿ®ÿ¥ÿ£ŸÜ ÿßŸÑÿÆÿµŸàÿµŸäÿ© ÿ£Ÿà ÿßŸÑÿ£ŸÖÿßŸÜ.\n\n"
                "ŸÑÿ£Ÿä ÿßÿ≥ÿ™ŸÅÿ≥ÿßÿ±ÿå ÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä."
            )
            await update.message.reply_text(headers_message, reply_markup=get_main_keyboard())
        except Exception as e:
            await update.message.reply_text("ÿπÿ∞ÿ±ÿßŸãÿå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ¨ŸÑÿ® ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ£ŸÖÿßŸÜ.", reply_markup=get_main_keyboard())
            logger.error(f"Error in _security_headers_command: {e}", exc_info=True)

    async def _grades_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            logger.info(f"üîç _grades_command called for user {update.effective_user.id}")
            context.user_data['last_action'] = 'grades'
            telegram_id = update.effective_user.id
            user = self.user_storage.get_user(telegram_id)
            logger.info(f"üìä User lookup result: {user is not None}")
            if not user:
                logger.warning(f"‚ùå User {telegram_id} not found in storage")
                await update.message.reply_text("‚ùóÔ∏è Ÿäÿ¨ÿ® ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ£ŸàŸÑÿßŸã.", reply_markup=get_unregistered_keyboard())
                return
            token = user.get("token")
            logger.info(f"üîë Token found: {token is not None}")
            if not token:
                logger.warning(f"‚ùå No token for user {telegram_id}")
                await update.message.reply_text("‚ùóÔ∏è Ÿäÿ¨ÿ® ÿ•ÿπÿßÿØÿ© ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ.", reply_markup=get_unregistered_keyboard())
                return
            logger.info(f"üåê Calling get_user_data for user {telegram_id}")
            user_data = await self.university_api.get_user_data(token)
            logger.info(f"üìä User data result: {user_data is not None}")
            grades = user_data.get("grades", []) if user_data else []
            logger.info(f"üìà Grades count: {len(grades) if grades else 0}")
            if not grades:
                logger.warning(f"‚ö†Ô∏è No grades found for user {telegram_id}")
                await update.message.reply_text("ŸÑÿß ŸäŸàÿ¨ÿØ ÿØÿ±ÿ¨ÿßÿ™ ŸÖÿ™ÿßÿ≠ÿ© ÿ®ÿπÿØ.", reply_markup=get_main_keyboard())
                return
            # Format grades with quote
            logger.info(f"üìù Formatting grades for user {telegram_id}")
            message = await self.grade_analytics.format_current_grades_with_quote(telegram_id, grades)
            logger.info(f"‚úÖ Sending formatted message to user {telegram_id}")
            await update.message.reply_text(message, parse_mode=ParseMode.MARKDOWN, reply_markup=get_main_keyboard())
        except Exception as e:
            logger.error(f"‚ùå Error in _grades_command: {e}", exc_info=True)
            is_registered = self.user_storage.is_user_registered(update.effective_user.id)
            keyboard = get_main_keyboard() if is_registered else get_unregistered_keyboard()
            await update.message.reply_text("‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ¨ŸÑÿ® ÿßŸÑÿØÿ±ÿ¨ÿßÿ™.", reply_markup=keyboard)

    async def _old_grades_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            context.user_data['last_action'] = 'old_grades'
            telegram_id = update.effective_user.id
            user = self.user_storage.get_user(telegram_id)
            if not user:
                await update.message.reply_text("‚ùóÔ∏è Ÿäÿ¨ÿ® ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ£ŸàŸÑÿßŸã.", reply_markup=get_unregistered_keyboard())
                return
            token = user.get("token")
            if not token:
                await update.message.reply_text("‚ùóÔ∏è Ÿäÿ¨ÿ® ÿ•ÿπÿßÿØÿ© ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ.", reply_markup=get_unregistered_keyboard())
                return
            old_grades = await self.university_api.get_old_grades(token)
            if old_grades is None:
                await update.message.reply_text("‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ£Ÿà ÿ¨ŸÑÿ® ÿßŸÑÿØÿ±ÿ¨ÿßÿ™. ÿ≠ÿßŸàŸÑ ŸÑÿßÿ≠ŸÇÿßŸã ÿ£Ÿà ÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿØÿπŸÖ.", reply_markup=get_main_keyboard())
                return
            if not old_grades:
                await update.message.reply_text("üìö ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿØÿ±ÿ¨ÿßÿ™ ÿ≥ÿßÿ®ŸÇÿ© ŸÖÿ™ÿßÿ≠ÿ© ŸÑŸÑŸÅÿµŸÑ ÿßŸÑÿØÿ±ÿßÿ≥Ÿä ÿßŸÑÿ≥ÿßÿ®ŸÇ.", reply_markup=get_main_keyboard())
                return
            formatted_message = await self.grade_analytics.format_old_grades_with_analysis(telegram_id, old_grades)
            # Split long messages if needed
            if len(formatted_message) > 4096:
                # Send message in chunks if too long
                for i in range(0, len(formatted_message), 4096):
                    await update.message.reply_text(formatted_message[i:i+4096], reply_markup=get_main_keyboard())
            else:
                await update.message.reply_text(formatted_message, reply_markup=get_main_keyboard())
        except Exception as e:
            logger.error(f"Error in _old_grades_command: {e}", exc_info=True)
            context.user_data.pop('last_action', None)
            is_registered = self.user_storage.is_user_registered(update.effective_user.id)
            keyboard = get_main_keyboard() if is_registered else get_unregistered_keyboard()
            await update.message.reply_text("‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ ÿ£ÿ´ŸÜÿßÿ° ÿ¨ŸÑÿ® ÿßŸÑÿØÿ±ÿ¨ÿßÿ™ ÿßŸÑÿ≥ÿßÿ®ŸÇÿ©. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÑÿßÿ≠ŸÇÿßŸã ÿ£Ÿà ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿØÿπŸÖ.", reply_markup=keyboard)

    async def _profile_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            telegram_id = update.effective_user.id
            user = self.user_storage.get_user(telegram_id)
            if not user:
                await update.message.reply_text("‚ùóÔ∏è Ÿäÿ¨ÿ® ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ£ŸàŸÑÿßŸã.", reply_markup=get_unregistered_keyboard())
                return
            msg = (
                f"üë§ **ŸÖÿπŸÑŸàŸÖÿßÿ™ŸÉ ÿßŸÑÿ¨ÿßŸÖÿπŸäÿ©:**\n"
                f"‚Ä¢ ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑŸÉÿßŸÖŸÑ: {user.get('fullname', '-')}\n"
                f"‚Ä¢ ÿßÿ≥ŸÖ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ¨ÿßŸÖÿπŸä: {user.get('username', '-')}\n"
            )
            try:
                await update.message.reply_text(msg, reply_markup=get_main_keyboard())
            except Exception as e:
                logger.error(f"Error sending profile message: {e}")
                await update.message.reply_text(msg, reply_markup=get_main_keyboard())
        except Exception as e:
            await update.message.reply_text("ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ¨ŸÑÿ® ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™.", reply_markup=get_unregistered_keyboard())
            logger.error(f"Error in _profile_command: {e}", exc_info=True)

    async def _settings_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await update.message.reply_text(
            "‚öôÔ∏è ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ≠ÿ≥ÿßÿ®\n\n"
            "ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ™ÿ≠ŸÉŸÖ ŸÅŸä ÿ®ŸäÿßŸÜÿßÿ™ŸÉ ŸàÿßŸÑŸàÿµŸàŸÑ ÿ•ŸÑŸâ ÿÆŸäÿßÿ±ÿßÿ™ ÿßŸÑÿÆÿµŸàÿµŸäÿ©.\n"
            "ŸÉŸÑ ÿ¥Ÿäÿ° ŸÅŸä Ÿáÿ∞ÿß ÿßŸÑÿ®Ÿàÿ™ ÿ¥ŸÅÿßŸÅ ŸàŸäŸÖŸÉŸÜŸÉ ÿØÿßÿ¶ŸÖÿßŸã ŸÖÿπÿ±ŸÅÿ© ŸÉŸäŸÅ Ÿäÿ™ŸÖ ÿßŸÑÿ™ÿπÿßŸÖŸÑ ŸÖÿπ ÿ®ŸäÿßŸÜÿßÿ™ŸÉ.\n\n"
            "- ŸäŸÖŸÉŸÜŸÉ ÿ≤Ÿäÿßÿ±ÿ© ÿßŸÑŸÉŸàÿØ ÿßŸÑÿ®ÿ±ŸÖÿ¨Ÿä ÿπŸÑŸâ GitHub."
        )

    def _get_contact_support_keyboard(self):
        """Returns an inline keyboard with a Contact Support button."""
        admin_username = CONFIG.get("ADMIN_USERNAME", "@admin")
        return InlineKeyboardMarkup([
            [InlineKeyboardButton("üìû ÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä", url=f"https://t.me/{admin_username.lstrip('@')}")]
        ])

    async def _support_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            admin_username = CONFIG.get("ADMIN_USERNAME", "@admin")
            await update.message.reply_text(
                f"üìû ŸÑŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä ÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑŸÖÿ∑Ÿàÿ±: {admin_username}\nÿßÿ∂ÿ∫ÿ∑ ÿßŸÑÿ≤ÿ± ÿ£ÿØŸÜÿßŸá ŸÑŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿ®ÿßÿ¥ÿ±ÿ©.",
                reply_markup=self._get_contact_support_keyboard()
            )
        except Exception as e:
            await update.message.reply_text("ÿπÿ∞ÿ±ÿßŸãÿå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿπÿ±ÿ∂ ÿßŸÑÿØÿπŸÖ.", reply_markup=get_main_keyboard())
            logger.error(f"Error in _support_command: {e}", exc_info=True)

    async def _admin_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        # Show admin dashboard for admin users
        if update.effective_user.id == CONFIG["ADMIN_ID"]:
            await self.admin_dashboard.show_dashboard(update, context)
        else:
            await update.message.reply_text("üö´ ŸÑŸäÿ≥ ŸÑÿØŸäŸÉ ÿµŸÑÿßÿ≠Ÿäÿ© ŸÑŸáÿ∞Ÿá ÿßŸÑÿπŸÖŸÑŸäÿ©.", reply_markup=get_main_keyboard())

    async def _handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        text = update.message.text
        user_id = update.effective_user.id
        is_registered = self.user_storage.is_user_registered(user_id)
        if text == "‚ùå ÿ•ŸÑÿ∫ÿßÿ°":
            keyboard = get_main_keyboard() if is_registered else get_unregistered_keyboard()
            await update.message.reply_text(
                "‚úÖ ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿπŸÖŸÑŸäÿ©. ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ®ÿØÿ° ŸÖŸÜ ÿ¨ÿØŸäÿØ ÿ£Ÿà ÿßÿÆÿ™Ÿäÿßÿ± ÿ•ÿ¨ÿ±ÿßÿ° ÿ¢ÿÆÿ±.",
                reply_markup=keyboard
            )
            context.user_data.clear()
            return
        try:
            # Admin: user search
            if user_id == CONFIG["ADMIN_ID"] and context.user_data.get('awaiting_user_search'):
                handled = await self.admin_dashboard.handle_user_search_message(update, context)
                if handled:
                    context.user_data.pop('awaiting_user_search', None)
                    return
            # Admin: user delete
            if user_id == CONFIG["ADMIN_ID"] and context.user_data.get('awaiting_user_delete'):
                handled = await self.admin_dashboard.handle_user_delete_message(update, context)
                if handled:
                    context.user_data.pop('awaiting_user_delete', None)
                    return
            # Admin: broadcast
            if user_id == CONFIG["ADMIN_ID"] and context.user_data.get('awaiting_broadcast'):
                handled = await self.admin_dashboard.handle_dashboard_message(update, context)
                if handled:
                    context.user_data.pop('awaiting_broadcast', None)
                    return
            # Admin: force grade check
            if context.user_data.get("awaiting_force_grade_check"):
                handled = await self.admin_dashboard.handle_force_grade_check_message(update, context)
                if handled:
                    return
            # Handle error recovery buttons
            if text in ["üîÑ ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©", "üè† ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©"]:
                await self._handle_error_recovery(update, context)
                return
            # Map button text to actions
            actions = {
                # Grade actions
                "üìä ÿØÿ±ÿ¨ÿßÿ™ ÿßŸÑŸÅÿµŸÑ ÿßŸÑÿ≠ÿßŸÑŸä": self._grades_command,
                "üìö ÿØÿ±ÿ¨ÿßÿ™ ÿßŸÑŸÅÿµŸÑ ÿßŸÑÿ≥ÿßÿ®ŸÇ": self._old_grades_command,
                # User actions
                "üë§ ŸÖÿπŸÑŸàŸÖÿßÿ™Ÿä ÿßŸÑÿ¥ÿÆÿµŸäÿ©": self._profile_command,
                "‚öôÔ∏è ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ ŸàÿßŸÑÿ™ÿÆÿµŸäÿµ": self._settings_command,
                # Support/help
                "üìû ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä": self._support_command,
                "‚ùì ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ© ŸàÿßŸÑÿØŸÑŸäŸÑ": self._help_command,
                # Registration
                "üöÄ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÑŸÑÿ¨ÿßŸÖÿπÿ©": self._register_start,
                # Admin
                "üéõÔ∏è ŸÑŸàÿ≠ÿ© ÿßŸÑÿ™ÿ≠ŸÉŸÖ ÿßŸÑÿ•ÿØÿßÿ±Ÿäÿ©": self._admin_command,
                "üîô ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑŸàÿ≠ÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©": self._return_to_main,
                # Legacy button support
                "üìä ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿØÿ±ÿ¨ÿßÿ™ ÿßŸÑŸÅÿµŸÑ ÿßŸÑÿ≠ÿßŸÑŸä": self._grades_command,
                "üìö ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿØÿ±ÿ¨ÿßÿ™ ÿßŸÑŸÅÿµŸÑ ÿßŸÑÿ≥ÿßÿ®ŸÇ": self._old_grades_command,
                "üë§ ŸÖÿπŸÑŸàŸÖÿßÿ™Ÿä": self._profile_command,
                "‚öôÔ∏è ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™": self._settings_command,
                "üìû ÿßŸÑÿØÿπŸÖ": self._support_command,
                "‚ùì ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ©": self._help_command,
                "üöÄ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ": self._register_start,
                "üéõÔ∏è ŸÑŸàÿ≠ÿ© ÿßŸÑÿ™ÿ≠ŸÉŸÖ": self._admin_command,
                "üîô ÿßŸÑÿπŸàÿØÿ©": self._return_to_main,
                # Info about bot
                "‚ùì ŸÉŸäŸÅ ŸäÿπŸÖŸÑ ÿßŸÑÿ®Ÿàÿ™ÿü": self._how_it_works_command,
                # Logout
                "üö™ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿÆÿ±Ÿàÿ¨": self._logout_command,
                # Refresh keyboard
                "üîÑ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ£ÿ≤ÿ±ÿßÿ±": self._refresh_keyboard,
            }
            action = actions.get(text)
            if action:
                await action(update, context)
            else:
                is_registered = self.user_storage.is_user_registered(user_id)
                keyboard = get_main_keyboard() if is_registered else get_unregistered_keyboard()
                await update.message.reply_text(
                    "Ÿáÿ∞Ÿá ÿßŸÑŸÖŸäÿ≤ÿ© ŸÇŸäÿØ ÿßŸÑÿ™ÿ∑ŸàŸäÿ±. ÿ≥Ÿäÿ™ŸÖ ÿ™ŸàŸÅŸäÿ±Ÿáÿß ŸÇÿ±Ÿäÿ®ÿßŸã.\n\nüìû ŸÑŸÑŸÖÿ≥ÿßÿπÿØÿ©: ÿßÿ∂ÿ∫ÿ∑ 'üìû ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä' ÿ£Ÿà ÿßŸÑÿ≤ÿ± ÿ£ÿØŸÜÿßŸá.",
                    reply_markup=keyboard
                )
        except Exception as e:
            logger.error(f"Error in _handle_message: {e}", exc_info=True)
            context.user_data.clear()
            is_registered = self.user_storage.is_user_registered(user_id)
            keyboard = get_main_keyboard() if is_registered else get_unregistered_keyboard()
            await update.message.reply_text(
                "‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ\n\n**ÿßŸÑÿ≠ŸÑŸàŸÑ:**\n‚Ä¢ ÿ¨ÿ±ÿ® ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ÿ®ÿπÿØ ŸÇŸÑŸäŸÑ\n‚Ä¢ ÿ•ÿ∞ÿß ÿßÿ≥ÿ™ŸÖÿ±ÿ™ ÿßŸÑŸÖÿ¥ŸÉŸÑÿ©ÿå ÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿØÿπŸÖ\n‚Ä¢ ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßÿ™ÿµÿßŸÑŸÉ ÿ®ÿßŸÑÿ•ŸÜÿ™ÿ±ŸÜÿ™\n\nüìû ŸÑŸÑŸÖÿ≥ÿßÿπÿØÿ©: ÿßÿ∂ÿ∫ÿ∑ 'üìû ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä' ÿ£Ÿà ÿßŸÑÿ≤ÿ± ÿ£ÿØŸÜÿßŸá.",
                reply_markup=keyboard
            )

    async def _handle_error_recovery(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle error recovery actions from the error recovery keyboard."""
        text = update.message.text
        user_id = update.effective_user.id
        
        if text == "üîÑ ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©":
            # Retry last action if possible
            last_action = context.user_data.get('last_action')
            if last_action:
                try:
                    if last_action == "grades":
                        await self._grades_command(update, context)
                    elif last_action == "old_grades":
                        await self._old_grades_command(update, context)
                    elif last_action == "profile":
                        await self._profile_command(update, context)
                    elif last_action == "settings":
                        await self._settings_command(update, context)
                    else:
                        await self._start_command(update, context)
                except Exception as e:
                    logger.error(f"Error in retry action: {e}")
                    await update.message.reply_text(
                        "‚ùå ŸÅÿ¥ŸÑÿ™ ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÑÿßÿ≠ŸÇÿßŸã.",
                        reply_markup=get_error_recovery_keyboard()
                    )
            else:
                await self._start_command(update, context)
        
        elif text == "üè† ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©":
            await self._start_command(update, context)
        
        elif text == "üìû ÿßŸÑÿØÿπŸÖ":
            await self._support_command(update, context)
        
        elif text == "‚ùì ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ©":
            await self._help_command(update, context)

    async def _handle_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if update.effective_user.id != CONFIG["ADMIN_ID"]: return
        query = update.callback_query
        await query.answer()
        # Delegate admin button clicks
        await self.admin_dashboard.handle_callback(update, context)

    async def _admin_notify_grades(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if update.effective_user.id != CONFIG["ADMIN_ID"]:
            await update.message.reply_text("üö´ ŸÑŸäÿ≥ ŸÑÿØŸäŸÉ ÿµŸÑÿßÿ≠Ÿäÿ© ŸÑŸáÿ∞Ÿá ÿßŸÑÿπŸÖŸÑŸäÿ©.", reply_markup=get_main_keyboard())
            return
        await update.message.reply_text("üîÑ ÿ¨ÿßÿ±Ÿä ŸÅÿ≠ÿµ ÿßŸÑÿØÿ±ÿ¨ÿßÿ™ ŸÑÿ¨ŸÖŸäÿπ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ...")
        count = await self._notify_all_users_grades()
        await update.message.reply_text(f"‚úÖ ÿ™ŸÖ ŸÅÿ≠ÿµ ÿßŸÑÿØÿ±ÿ¨ÿßÿ™ Ÿàÿ•ÿ¥ÿπÿßÿ± {count} ŸÖÿ≥ÿ™ÿÆÿØŸÖ (ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸáŸÜÿßŸÉ ÿ™ÿ∫ŸäŸäÿ±).", reply_markup=get_main_keyboard())

    async def _grade_checking_loop(self):
        await asyncio.sleep(10)  # Wait a bit before starting grade check
        while self.running:
            try:
                logger.info("üîî Running scheduled grade check for all users...")
                await self._notify_all_users_grades()
            except Exception as e:
                logger.error(f"‚ùå Error in scheduled grade check: {e}", exc_info=True)
            interval = CONFIG.get('GRADE_CHECK_INTERVAL', 10) * 60
            await asyncio.sleep(interval)

    async def _notify_all_users_grades(self):
        users = self.user_storage.get_all_users()
        notified_count = 0
        semaphore = asyncio.Semaphore(CONFIG.get('MAX_CONCURRENT_REQUESTS', 5))
        tasks = []
        results = []

        async def check_user(user):
            async with semaphore:
                try:
                    return await self._check_and_notify_user_grades(user)
                except Exception as e:
                    logger.error(f"‚ùå Error in parallel grade check for user {user.get('username', 'Unknown')}: {e}", exc_info=True)
                    return False

        for user in users:
            tasks.append(asyncio.create_task(check_user(user)))
        if tasks:
            results = await asyncio.gather(*tasks, return_exceptions=True)
            notified_count = sum(1 for r in results if r is True)
        return notified_count

    async def _check_and_notify_user_grades(self, user):
        try:
            telegram_id = user.get("telegram_id")
            username = user.get("username")
            token = user.get("token")
            # Notify only once if token expired
            if not token:
                return False
            is_pg = hasattr(self.user_storage, 'update_token_expired_notified')
            notified = user.get("token_expired_notified", False)
            if not await self.university_api.test_token(token):
                if not notified:
                    await self.app.bot.send_message(
                        chat_id=telegram_id,
                        text="‚è∞ ÿßŸÜÿ™Ÿáÿ™ ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑÿ¨ŸÑÿ≥ÿ©\n\nŸäÿ±ÿ¨Ÿâ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÖŸÜ ÿÆŸÑÿßŸÑ ÿ≤ÿ± 'üöÄ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÑŸÑÿ¨ÿßŸÖÿπÿ©' ÿ´ŸÖ ÿ•ÿØÿÆÿßŸÑ ÿ®ŸäÿßŸÜÿßÿ™ŸÉ ŸÖŸÜ ÿ¨ÿØŸäÿØ. Ÿáÿ∞ÿß ÿ∑ÿ®ŸäÿπŸä ŸàŸäÿ≠ÿØÿ´ ŸÉŸÑ ŸÅÿ™ÿ±ÿ©.",
                        reply_markup=get_unregistered_keyboard()
                    )
                    # Mark as notified
                    if is_pg:
                        self.user_storage.update_token_expired_notified(telegram_id, True)
                    else:
                        # Update file storage
                        user["token_expired_notified"] = True
                        if hasattr(self.user_storage, '_save_users'):
                            self.user_storage._save_users()
                return False
            # Reset notification flag if token is valid
            if notified:
                if is_pg:
                    self.user_storage.update_token_expired_notified(telegram_id, False)
                else:
                    # Update file storage
                    user["token_expired_notified"] = False
                    if hasattr(self.user_storage, '_save_users'):
                        self.user_storage._save_users()
            user_data = await self.university_api.get_user_data(token)
            if not user_data or "grades" not in user_data:
                logger.info(f"No grade data available for {username} in this check.")
                return False
            new_grades = user_data.get("grades", [])
            old_grades = self.grade_storage.get_user_grades(telegram_id)
            changed_courses = self._compare_grades(old_grades, new_grades)
            if changed_courses:
                logger.warning(f"GRADE CHECK: Found {len(changed_courses)} grade changes for user {username}. Sending notification.")
                display_name = user.get('fullname') or user.get('username', 'ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ')
                message = f"üéì ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿØÿ±ÿ¨ÿßÿ™ŸÉ ŸÅŸä ÿßŸÑŸÖŸàÿßÿØ ÿßŸÑÿ™ÿßŸÑŸäÿ©:\n\n"
                old_map = {g.get('code') or g.get('name'): g for g in old_grades if g.get('code') or g.get('name')}
                for grade in changed_courses:
                    name = grade.get('name', 'N/A')
                    code = grade.get('code', '-')
                    coursework = grade.get('coursework', 'ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑŸÜÿ¥ÿ±')
                    final_exam = grade.get('final_exam', 'ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑŸÜÿ¥ÿ±')
                    total = grade.get('total', 'ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑŸÜÿ¥ÿ±')
                    key = code if code != '-' else name
                    old = old_map.get(key, {})
                    def show_change(field, label):
                        old_val = old.get(field, '‚Äî')
                        new_val = grade.get(field, '‚Äî')
                        if old_val != new_val and old_val != '‚Äî':
                            return f"{label}: {old_val} ‚Üí {new_val}"
                        return None
                    changes = [
                        show_change('coursework', 'ÿßŸÑÿ£ÿπŸÖÿßŸÑ'),
                        show_change('final_exam', 'ÿßŸÑŸÜÿ∏ÿ±Ÿä'),
                        show_change('total', 'ÿßŸÑŸÜŸáÿßÿ¶Ÿä'),
                    ]
                    changes = [c for c in changes if c]
                    if changes:
                        message += f"üìö {name} ({code})\n" + "\n".join(changes) + "\n\n"
                now_utc3 = datetime.now(timezone.utc) + timedelta(hours=3)
                message += f"üïí ŸàŸÇÿ™ ÿßŸÑÿ™ÿ≠ÿØŸäÿ´: {now_utc3.strftime('%Y-%m-%d %H:%M')} (UTC+3)"
                await self.app.bot.send_message(chat_id=telegram_id, text=message)
                return True
            return False
        except Exception as e:
            logger.error(f"‚ùå Error in _check_and_notify_user_grades for user {user.get('username', 'Unknown')}: {e}", exc_info=True)
            return False

    def _compare_grades(self, old_grades: List[Dict], new_grades: List[Dict]) -> List[Dict]:
        """
        Return only courses where important fields (total, coursework, final_exam) changed.
        """
        def extract_relevant(grade):
            return {
                'code': grade.get('code') or grade.get('name'),
                'total': grade.get('total'),
                'coursework': grade.get('coursework'),
                'final_exam': grade.get('final_exam'),
            }
        old_map = {g.get('code') or g.get('name'): extract_relevant(g) for g in old_grades if g.get('code') or g.get('name')}
        changed = []
        for new_grade in new_grades:
            key = new_grade.get('code') or new_grade.get('name')
            if not key:
                continue
            relevant_new = extract_relevant(new_grade)
            relevant_old = old_map.get(key)
            if relevant_old is None or relevant_new != relevant_old:
                changed.append(new_grade)
        return changed

    async def _register_start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        
        # Rate limiting
        if not security_manager.check_login_attempt(user_id):
            await update.message.reply_text(
                "üö´ ÿ™ŸÖ ÿ≠ÿ∏ÿ± ŸÖÿ≠ÿßŸàŸÑÿßÿ™ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÖÿ§ŸÇÿ™ÿßŸã ÿ®ÿ≥ÿ®ÿ® ŸÉÿ´ÿ±ÿ© ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿßÿ™ ÿßŸÑŸÅÿßÿ¥ŸÑÿ©.\n"
                "Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ÿ®ÿπÿØ 15 ÿØŸÇŸäŸÇÿ©.",
                reply_markup=get_unregistered_keyboard()
            )
            return ConversationHandler.END
        
        # Clear previous session and user data
        existing_user = self.user_storage.get_user(user_id)
        if existing_user:
            logger.info(f"User {user_id} is relogging in. Clearing existing session.")
            # Invalidate session
            if hasattr(security_manager, 'session_manager'):
                security_manager.session_manager.invalidate_session(user_id)
            # Clear user data from context
            context.user_data.clear()
            # Remove user token
            if hasattr(self.user_storage, 'clear_user_token'):
                # For PostgreSQL storage
                self.user_storage.clear_user_token(user_id)
            else:
                # For file storage
                existing_user["token"] = None
                existing_user["token_expired_notified"] = False
                if hasattr(self.user_storage, '_save_users'):
                    self.user_storage._save_users()
        
        # Show security info before asking for credentials
        await update.message.reply_text(get_credentials_security_info_message())
        
        await update.message.reply_text(
            "Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ÿßŸÑŸÉŸàÿØ ÿßŸÑÿ¨ÿßŸÖÿπŸä ÿßŸÑÿÆÿßÿµ ÿ®ŸÉ. ÿ•ÿ∞ÿß ÿßÿ≠ÿ™ÿ¨ÿ™ ŸÑŸÑŸÖÿ≥ÿßÿπÿØÿ©ÿå ÿßÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ '‚ùì ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ©'."
        )
        return ASK_USERNAME

    async def _register_username(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        username = update.message.text.strip()
        
        # Validate username length
        if not is_valid_length(username, min_len=7, max_len=20):
            await update.message.reply_text(
                "‚ùå ÿßŸÑŸÉŸàÿØ ÿßŸÑÿ¨ÿßŸÖÿπŸä Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿ®ŸäŸÜ 7 Ÿà 20 ÿ≠ÿ±ŸÅ.\n\n"
                "‚ùå University code must be between 7 and 20 characters."
            )
            return ASK_USERNAME
        
        # Validate university code format
        if not re.fullmatch(r"[A-Za-z]{3,}[0-9]{4,}", username):
            await update.message.reply_text(
                "‚ùå ÿßŸÑŸÉŸàÿØ ÿßŸÑÿ¨ÿßŸÖÿπŸä Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿπŸÑŸâ ÿßŸÑÿ¥ŸÉŸÑ: 3 ÿ£ÿ≠ÿ±ŸÅ ÿ£Ÿà ÿ£ŸÉÿ´ÿ± ÿ´ŸÖ 4 ÿ£ÿ±ŸÇÿßŸÖ ÿ£Ÿà ÿ£ŸÉÿ´ÿ± (ŸÖÿ´ÿßŸÑ: ENG2425041).\n\n"
                "‚ùå University code must be in the form: 3+ letters then 4+ digits (e.g., ENG2425041)."
            )
            return ASK_USERNAME
        
        context.user_data['username'] = username
        await update.message.reply_text("Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±:")
        await update.message.reply_text(
            "üîí ŸÖŸÑÿßÿ≠ÿ∏ÿ©: ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ŸÑÿß ÿ™ŸèÿÆÿ≤ŸÜ ŸÜŸáÿßÿ¶ŸäÿßŸã Ÿàÿ™Ÿèÿ≥ÿ™ÿÆÿØŸÖ ŸÅŸÇÿ∑ ŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ. ÿ®ŸäÿßŸÜÿßÿ™ŸÉ ÿ¢ŸÖŸÜÿ© ÿ®ÿßŸÑŸÉÿßŸÖŸÑ.\n"
            "ŸÜÿ≥ÿ™ÿÆÿØŸÖ ÿ±ŸÖÿ≤ ÿØÿÆŸàŸÑ ŸÖÿ§ŸÇÿ™ (Token) ÿ®ÿØŸÑÿßŸã ŸÖŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ŸÑÿ≠ŸÖÿßŸäÿ© ÿ≠ÿ≥ÿßÿ®ŸÉ.\n"
            "_Note: Your password is never stored and is used only for login. Your data is fully secure._\n"
            "We use a temporary login token instead of your password to keep your account safe."
        )
        return ASK_PASSWORD

    async def _register_password(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        username = context.user_data.get('username')
        password = update.message.text.strip()
        telegram_id = update.effective_user.id
        
        # Make sure username is set
        if not username:
            await update.message.reply_text(
                "‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.",
                reply_markup=get_unregistered_keyboard()
            )
            return ConversationHandler.END
        
        # Validate password
        if not is_valid_length(password, min_len=1, max_len=100):
            await update.message.reply_text(
                "‚ùå ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©.\n\n"
                "‚ùå Invalid password format."
            )
            return ASK_PASSWORD
        
        # Check for invalid password characters
        if any(char in password for char in ['<', '>', '"', "'", '&', ';', '|', '`', '$', '(', ')', '{', '}']):
            await update.message.reply_text(
                "‚ùå ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿ™ÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿ±ŸÖŸàÿ≤ ÿ∫Ÿäÿ± ŸÖÿ≥ŸÖŸàÿ≠ÿ©.\n\n"
                "‚ùå Password contains invalid characters."
            )
            return ASK_PASSWORD
        
        # Try to log in with university API
        await update.message.reply_text("üîÑ ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ®ŸäÿßŸÜÿßÿ™ŸÉ...\nChecking your credentials...")
        token = await self.university_api.login(username, password)
        
        # Record login attempt
        success = token is not None
        security_manager.record_login_attempt(telegram_id, success, username)
        
        if not token:
            await update.message.reply_text(
                "‚ùå ÿ™ÿπÿ∞Ÿëÿ± ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿµÿ≠ÿ© ÿßÿ≥ŸÖ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸàŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿßŸÑÿ¨ÿßŸÖÿπŸäÿ© Ÿàÿ•ÿπÿßÿØÿ© ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©.\n\n"
                "Login failed. Please check your university username and password and try again.",
                reply_markup=get_unregistered_keyboard()
            )
            # Restart registration from username
            return await self._register_start(update, context)
        
        # Get user info for welcome message
        logger.info(f"üîç Fetching user info for registration...")
        user_info = await self.university_api.get_user_info(token)
        logger.info(f"üîç User info result: {user_info}")
        
        if user_info:
            # The API returns 'fullname', 'firstname', 'lastname' fields
            api_fullname = user_info.get('fullname', '')
            api_firstname = user_info.get('firstname', '')
            api_lastname = user_info.get('lastname', '')
            api_username = user_info.get('username', username)
            email = user_info.get('email', '-')
            
            logger.info(f"üîç API fullname: '{api_fullname}', firstname: '{api_firstname}', lastname: '{api_lastname}', username: '{api_username}', email: '{email}'")
            
            # Use the API name fields if available, otherwise use a more user-friendly fallback
            if api_fullname and api_fullname.strip():
                fullname = api_fullname.strip()
                logger.info(f"‚úÖ Using API fullname: '{fullname}'")
                # Use the individual name fields if available, otherwise split the fullname
                if api_firstname and api_firstname.strip():
                    firstname = api_firstname.strip()
                    lastname = api_lastname.strip() if api_lastname else ''
                else:
                    # Fallback: split fullname into first and last
                    name_parts = fullname.split()
                    if len(name_parts) >= 2:
                        firstname = name_parts[0]
                        lastname = ' '.join(name_parts[1:])
                    else:
                        firstname = fullname
                        lastname = ''
            else:
                # Fallback: use a more descriptive name instead of student ID
                logger.warning(f"‚ö†Ô∏è API fullname is empty or whitespace, using fallback")
                fullname = f"ÿ∑ÿßŸÑÿ® ÿ¨ÿßŸÖÿπÿ© ÿßŸÑÿ¥ÿßŸÖ ({api_username})"
                firstname = "ÿ∑ÿßŸÑÿ®"
                lastname = "ÿ¨ÿßŸÖÿπÿ© ÿßŸÑÿ¥ÿßŸÖ"
        else:
            # Fallback when API call fails
            logger.warning(f"‚ö†Ô∏è User info API call failed, using fallback")
            fullname = f"ÿ∑ÿßŸÑÿ® ÿ¨ÿßŸÖÿπÿ© ÿßŸÑÿ¥ÿßŸÖ ({username})"
            firstname = "ÿ∑ÿßŸÑÿ®"
            lastname = "ÿ¨ÿßŸÖÿπÿ© ÿßŸÑÿ¥ÿßŸÖ"
            email = '-'
        
        user_data = {
            "username": username,
            "fullname": fullname,
            "firstname": firstname,
            "lastname": lastname,
            "email": email
        }
        logger.info(f"üîç About to save user: telegram_id={telegram_id}, username={username}, token_length={len(token) if token else 0}, user_data={user_data}")
        logger.info(f"üîç Storage class type: {type(self.user_storage).__name__}")
        logger.info(f"üîç Storage class methods: {[method for method in dir(self.user_storage) if not method.startswith('_')]}")
        try:
            success = self.user_storage.save_user(telegram_id, username, token, user_data)
            if not success:
                logger.error(f"‚ùå Failed to save user {username}")
                await update.message.reply_text("‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ŸÅÿ∏ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.", reply_markup=get_unregistered_keyboard())
                return
            logger.info(f"‚úÖ User saved successfully")
        except Exception as e:
            logger.error(f"‚ùå Error saving user: {e}", exc_info=True)
            raise
        
        # Create session
        try:
            security_manager.create_user_session(telegram_id, token, user_data)
            logger.info(f"‚úÖ User session created successfully")
        except Exception as e:
            logger.error(f"‚ùå Error creating user session: {e}", exc_info=True)
            # Don't raise here, continue with registration
        
        # Show welcome message with keyboard
        welcome_message = get_welcome_message(fullname)
        try:
            # Try to send welcome message with keyboard
            await update.message.reply_text(welcome_message, reply_markup=get_main_keyboard())
        except Exception as e:
            logger.error(f"Error sending welcome message: {e}")
            # Fallback: send message without keyboard
            await update.message.reply_text(welcome_message)
        return ConversationHandler.END

    async def _return_to_main(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Return to main keyboard from admin interface"""
        keyboard_to_show = get_main_keyboard() if self.user_storage.is_user_registered(update.effective_user.id) else get_unregistered_keyboard()
        await update.message.reply_text(
            "ÿ™ŸÖÿ™ ÿßŸÑÿπŸàÿØÿ© ÿ•ŸÑŸâ ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©.",
            reply_markup=keyboard_to_show
        )

    async def _cancel_registration(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await update.message.reply_text("ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ.", reply_markup=get_main_keyboard())
        return ConversationHandler.END

    async def send_quote_to_all_users(self, message):
        users = self.user_storage.get_all_users()
        sent = 0
        for user in users:
            try:
                await self.app.bot.send_message(chat_id=user['telegram_id'], text=message)
                sent += 1
            except Exception:
                continue
        return sent

    async def scheduled_daily_quote_broadcast(self):
        """Send daily quote to all users at scheduled time"""
        import pytz
        from datetime import datetime, time, timedelta
        tz = pytz.timezone('Asia/Riyadh')
        # Get schedule from environment
        def get_scheduled_time():
            time_str = os.getenv("QUOTE_SCHEDULE", "14:00")
            try:
                hour, minute = map(int, time_str.strip().split(":"))
                if 0 <= hour < 24 and 0 <= minute < 60:
                    return hour, minute
            except Exception:
                pass
            return 14, 0  # default time
        target_hour, target_minute = get_scheduled_time()
        logger.info(f"üïë Daily quote scheduler started (UTC+3) at {target_hour:02d}:{target_minute:02d}")
        while self.running:
            now = datetime.now(tz)
            next_run = now.replace(hour=target_hour, minute=target_minute, second=0, microsecond=0)
            if now >= next_run:
                next_run += timedelta(days=1)
            wait_seconds = (next_run - now).total_seconds()
            logger.info(f"Next daily quote broadcast in {wait_seconds/60:.1f} minutes")
            await asyncio.sleep(wait_seconds)
            if not self.running:
                break
            # Fetch and send the quote
            quote = await self.grade_analytics.get_daily_quote()
            if quote:
                message = await self.grade_analytics.format_quote_dual_language(quote)
            else:
                message = "üí¨ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸäŸàŸÖ:\n\nŸÑŸÖ ÿ™ÿ™ŸàŸÅÿ± ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸäŸàŸÖ ÿ≠ÿßŸÑŸäÿßŸã."
            count = await self.send_quote_to_all_users(message)
            logger.info(f"‚úÖ ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸäŸàŸÖ ÿ•ŸÑŸâ {count} ŸÖÿ≥ÿ™ÿÆÿØŸÖ.")

    async def _how_it_works_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await update.message.reply_text(
            "ü§ñ Ÿáÿ∞ÿß ÿßŸÑÿ®Ÿàÿ™ Ÿäÿ≥ÿßÿπÿØŸÉ ŸÅŸä ŸÖÿ™ÿßÿ®ÿπÿ© ÿØÿ±ÿ¨ÿßÿ™ŸÉ ÿßŸÑÿ¨ÿßŸÖÿπŸäÿ© ÿ®ÿ≥ŸáŸàŸÑÿ© Ÿàÿ£ŸÖÿßŸÜ!\n\n"
            "‚Ä¢ ŸäŸÖŸÉŸÜŸÉ ŸÖÿπÿ±ŸÅÿ© ÿØÿ±ÿ¨ÿßÿ™ŸÉ ÿßŸÑÿ≠ÿßŸÑŸäÿ© ŸàÿßŸÑÿ≥ÿßÿ®ŸÇÿ© ŸÅŸä ÿ£Ÿä ŸàŸÇÿ™\n"
            "‚Ä¢ ÿ™ÿµŸÑŸÉ ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ŸÅŸàÿ±Ÿäÿ© ÿπŸÜÿØ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿØÿ±ÿ¨ÿßÿ™\n"
            "‚Ä¢ ŸÉŸÑ ÿ®ŸäÿßŸÜÿßÿ™ŸÉ ŸÖÿ¥ŸÅÿ±ÿ© Ÿàÿ¢ŸÖŸÜÿ© ŸàŸÑÿß Ÿäÿ™ŸÖ ÿ™ÿÆÿ≤ŸäŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±\n"
            "‚Ä¢ ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä ŸÑÿ£Ÿä ÿßÿ≥ÿ™ŸÅÿ≥ÿßÿ±\n\n"
            "ÿßÿ®ÿØÿ£ ÿßŸÑÿ¢ŸÜ ÿ®ÿßŸÑÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ 'üöÄ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÑŸÑÿ¨ÿßŸÖÿπÿ©'!"
        )

    async def _broadcast_quote(self, context: ContextTypes.DEFAULT_TYPE):
        try:
            quote = await self.grade_analytics.get_daily_quote()
            if not quote:
                logger.warning("No quote available for broadcast.")
                return
            # Format quote in two languages
            quote_text = await self.grade_analytics.format_quote_dual_language(quote)
            for user in self.user_storage.get_all_users():
                telegram_id = user.get("telegram_id")
                if telegram_id:
                    try:
                        await context.bot.send_message(chat_id=telegram_id, text=quote_text, parse_mode=ParseMode.MARKDOWN)
                    except Exception as e:
                        logger.warning(f"Failed to send quote to {telegram_id}: {e}")
        except Exception as e:
            logger.error(f"Error in _broadcast_quote: {e}")

    async def _refresh_keyboard(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Refresh keyboard based on user registration status"""
        user = self.user_storage.get_user(update.effective_user.id)
        if user:
            await update.message.reply_text(
                "‚úÖ ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ£ÿ≤ÿ±ÿßÿ± ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿßŸÑŸÖÿ≥ÿ¨ŸÑŸäŸÜ.",
                reply_markup=get_main_keyboard()
            )
        else:
            await update.message.reply_text(
                "‚ùå ÿ£ŸÜÿ™ ÿ∫Ÿäÿ± ŸÖÿ≥ÿ¨ŸÑ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ£ŸàŸÑÿßŸã.",
                reply_markup=get_unregistered_keyboard()
            )

    async def _logout_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        telegram_id = update.effective_user.id
        # End user session
        if hasattr(security_manager, 'session_manager'):
            security_manager.session_manager.invalidate_session(telegram_id)
        # Remove user token and mark as inactive
        user = self.user_storage.get_user(telegram_id)
        if user:
            if hasattr(self.user_storage, 'clear_user_token'):
                # For PostgreSQL storage
                self.user_storage.clear_user_token(telegram_id)
            else:
                # For file storage
                user["token"] = None
                user["is_active"] = False
                if hasattr(self.user_storage, '_save_users'):
                    self.user_storage._save_users()
        await update.message.reply_text(
            "‚úÖ ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿÆÿ±Ÿàÿ¨ ÿ®ŸÜÿ¨ÿßÿ≠. ŸäŸÖŸÉŸÜŸÉ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÅŸä ÿ£Ÿä ŸàŸÇÿ™.",
            reply_markup=get_unregistered_keyboard()
        )

    async def _settings_callback_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        await query.answer()
        if query.data == "back_to_main":
            await query.edit_message_text(
                "ÿ™ŸÖÿ™ ÿßŸÑÿπŸàÿØÿ© ÿ•ŸÑŸâ ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©.\n\n"
                "ŸÜÿ≠ŸÜ ŸÜŸÇÿØÿ± ÿ´ŸÇÿ™ŸÉ ŸàŸÜÿ≥ÿπŸâ ÿØÿßÿ¶ŸÖÿßŸã ŸÑŸÑÿ¥ŸÅÿßŸÅŸäÿ© ŸÅŸä ŸÉŸÑ ŸÖÿß Ÿäÿ™ÿπŸÑŸÇ ÿ®ÿ®ŸäÿßŸÜÿßÿ™ŸÉ."
            )
        elif query.data == "cancel_action":
            is_registered = self.user_storage.is_user_registered(update.effective_user.id)
            keyboard = get_main_keyboard() if is_registered else get_unregistered_keyboard()
            await query.edit_message_text(
                "‚úÖ ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿπŸÖŸÑŸäÿ©. ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ®ÿØÿ° ŸÖŸÜ ÿ¨ÿØŸäÿØ ÿ£Ÿà ÿßÿÆÿ™Ÿäÿßÿ± ÿ•ÿ¨ÿ±ÿßÿ° ÿ¢ÿÆÿ±.",
            )
            await update.effective_chat.send_message(
                "ÿ™ŸÖÿ™ ÿ•ÿπÿßÿØÿ™ŸÉ ŸÑŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©.",
                reply_markup=keyboard
            )
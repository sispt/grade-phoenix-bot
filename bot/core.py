"""
üéì Telegram Bot Core - Main Bot Implementation
"""
import asyncio
from datetime import datetime, timedelta, timezone

from sqlalchemy import update
from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.constants import ParseMode
from telegram.ext import (
    Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters,
    ContextTypes, ConversationHandler
)
from typing import Dict, List
import re
import os
import json

from config import CONFIG
from storage.models import DatabaseManager
from storage.user_storage_v2 import UserStorageV2
from storage.grade_storage_v2 import GradeStorageV2
from admin.dashboard import AdminDashboard
from admin.broadcast import BroadcastSystem
from utils.keyboards import (
    get_main_keyboard, get_main_keyboard_with_admin, get_admin_keyboard, get_cancel_keyboard, 
    get_unregistered_keyboard, remove_keyboard, get_error_recovery_keyboard, get_registration_keyboard,
    get_enhanced_admin_dashboard_keyboard, get_user_management_keyboard, get_broadcast_confirmation_keyboard,
    get_system_actions_keyboard, get_settings_main_keyboard, get_session_settings_keyboard,
    get_privacy_settings_keyboard, get_contact_support_inline_keyboard
)
from utils.messages import get_welcome_message, get_help_message, get_simple_welcome_message, get_security_welcome_message, get_credentials_security_info_message
from security.enhancements import security_manager, is_valid_length
from security.headers import security_headers, security_policy
from utils.analytics import GradeAnalytics
from utils.settings import UserSettings
from university.api_client_v2 import UniversityAPIV2
from utils.logger import get_bot_logger

# Get bot logger
logger = get_bot_logger()
# Add new states for session choice and password confirmation
ASK_USERNAME, ASK_PASSWORD, ASK_SESSION_TYPE, ASK_PASSWORD_CONFIRM = range(4)
ASK_GPA_COURSE_COUNT, ASK_GPA_PERCENTAGE, ASK_GPA_ECTS = range(10, 13)
# Add new states for settings/session management
ASK_SETTINGS_MAIN, ASK_SESSION_MANAGEMENT = 20, 21
# Add new state for older terms selection
ASK_OLDER_TERM_NUMBER = 30

class TelegramBot:
    """Main Telegram Bot Class"""
    
    def __init__(self):
        self.app, self.db_manager, self.user_storage, self.grade_storage = None, None, None, None
        self.university_api = UniversityAPIV2()
        # Initialize storage before other components
        self._initialize_storage() 
        # Initialize components that depend on storage
        self.grade_analytics = GradeAnalytics(self.user_storage)
        self.user_settings = UserSettings(self.user_storage)
        self.admin_dashboard = AdminDashboard(self)
        self.broadcast_system = BroadcastSystem(self)
        self.grade_check_task = None
        self.running = False
        self._user_locks = {}  # username_unique: asyncio.Lock

    def _initialize_storage(self):
        pg_initialized = False
        # Initialize new clean storage systems
        try:
            logger.info("üóÑÔ∏è Initializing new clean storage systems...")
            self.user_storage = UserStorageV2(CONFIG["MYSQL_URL"])
            self.grade_storage = GradeStorageV2(CONFIG["MYSQL_URL"])
            logger.info("‚úÖ New storage systems initialized successfully.")
        except Exception as e:
            logger.critical(f"‚ùå FATAL: Storage initialization failed. Bot cannot run: {e}", exc_info=True)
            raise RuntimeError("Failed to initialize storage systems.")

    def _get_user_lock(self, username_unique):
        if username_unique not in self._user_locks:
            self._user_locks[username_unique] = asyncio.Lock()
        return self._user_locks[username_unique]

    async def start(self):
        self.running = True
        self.app = Application.builder().token(CONFIG["TELEGRAM_TOKEN"]).build()
        await self._update_bot_info()
        self._add_handlers()
        await self.app.initialize()
        await self.app.start()
        port = int(os.environ.get("PORT", 8000))
        
        # Try to get Railway URL from environment
        railway_app_name = os.getenv("RAILWAY_APP_NAME")
        
        # Use WEBHOOK_URL if it's a full URL
        webhook_url_env = os.getenv("WEBHOOK_URL")
        if webhook_url_env and webhook_url_env.startswith("https://"):
            # Use the provided webhook URL
            webhook_url = webhook_url_env
            railway_url = webhook_url_env.replace(f"/{CONFIG['TELEGRAM_TOKEN']}", "")
        else:
            # Build webhook URL from Railway domain
            railway_url = (
                webhook_url_env or 
                os.getenv("RAILWAY_STATIC_URL") or 
                os.getenv("RAILWAY_PUBLIC_DOMAIN") or
                os.getenv("RAILWAY_DOMAIN") or
                (f"{railway_app_name}.up.railway.app" if railway_app_name else None) or
                "your-app-name.up.railway.app"  # fallback if nothing else is set
            )
            
            # Final webhook URL
            webhook_url = f"https://{railway_url}/{CONFIG['TELEGRAM_TOKEN']}"
        
        logger.info(f"üåê Webhook URL: {webhook_url}")
        logger.info(f"üîß Railway URL source: {railway_url}")
        
        await self.app.updater.start_webhook(listen="0.0.0.0", port=port, url_path=CONFIG["TELEGRAM_TOKEN"], webhook_url=webhook_url)
        logger.info(f"‚úÖ Bot started on webhook: {webhook_url}")

        # Start background tasks only if not running under cron
        if os.getenv("RUN_GRADE_CHECK") != "1":
            self.grade_check_task = asyncio.create_task(self._grade_checking_loop())
            self.daily_quote_task = asyncio.create_task(self.scheduled_daily_quote_broadcast())

    async def _update_bot_info(self):
        try:
            # Only update bot name/description if needed
            current_name = await self.app.bot.get_my_name()
            if current_name.name != CONFIG["BOT_NAME"]:
                try:
                    await self.app.bot.set_my_name(CONFIG["BOT_NAME"])
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Failed to set bot name: {e}")
            current_desc = await self.app.bot.get_my_description()
            if current_desc.description != CONFIG["BOT_DESCRIPTION"]:
                try:
                    await self.app.bot.set_my_description(CONFIG["BOT_DESCRIPTION"])
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Failed to set bot description: {e}")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Failed to update bot info: {e}")

    async def stop(self):
        self.running = False
        if self.grade_check_task:
            self.grade_check_task.cancel()
        if hasattr(self, 'daily_quote_task') and self.daily_quote_task:
            self.daily_quote_task.cancel()
        if self.app:
            await self.app.stop()
            await self.app.shutdown()
        logger.info("üõë Bot stopped.")

    def _add_handlers(self):
        # Register all bot handlers
        registration_handler = ConversationHandler(
            entry_points=[
                CommandHandler("register", self._register_start),
                MessageHandler(filters.Regex("^üöÄ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÑŸÑÿ¨ÿßŸÖÿπÿ©$"), self._register_start)
            ],
            states={
                ASK_USERNAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, self._register_username)],
                ASK_PASSWORD: [MessageHandler(filters.TEXT & ~filters.COMMAND, self._register_password)],
                ASK_SESSION_TYPE: [MessageHandler(filters.TEXT & ~filters.COMMAND, self._register_session_type)],
                ASK_PASSWORD_CONFIRM: [MessageHandler(filters.TEXT & ~filters.COMMAND, self._register_password_confirm)],
            },
            fallbacks=[CommandHandler("cancel", self._cancel_registration), MessageHandler(filters.Regex("^‚ùå ÿ•ŸÑÿ∫ÿßÿ°$"), self._cancel_registration)],
        )
        self.app.add_handler(registration_handler)
        self.app.add_handler(self.broadcast_system.get_conversation_handler())
        self.app.add_handler(CommandHandler("start", self._start_command))
        self.app.add_handler(CommandHandler("help", self._help_command))
        self.app.add_handler(CommandHandler("grades", self._grades_command))
        self.app.add_handler(CommandHandler("old_grades", self._old_grades_command))
        self.app.add_handler(CommandHandler("profile", self._profile_command))
        self.app.add_handler(CommandHandler("settings", self._settings_command))
        self.app.add_handler(CommandHandler("support", self._support_command))
        # Security-related commands
        self.app.add_handler(CommandHandler("security_info", self._security_info_command))
        self.app.add_handler(CommandHandler("security_audit", self._security_audit_command))
        self.app.add_handler(CommandHandler("privacy_policy", self._privacy_policy_command))
        self.app.add_handler(CommandHandler("security_stats", self._security_stats_command))
        self.app.add_handler(CommandHandler("security_headers", self._security_headers_command))
        # Admin panel command
        self.app.add_handler(CommandHandler("admin", self._admin_command))
        self.app.add_handler(CommandHandler("notify_grades", self._admin_notify_grades))
        self.app.add_handler(CallbackQueryHandler(self._handle_callback))
        gpa_calc_handler = ConversationHandler(
            entry_points=[MessageHandler(filters.Regex("^üßÆ ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÖÿπÿØŸÑ ÿßŸÑŸÖÿÆÿµÿµ$"), self._gpa_calc_start)],
            states={
                ASK_GPA_COURSE_COUNT: [
                    MessageHandler(filters.Regex("^‚ùå ÿ•ŸÑÿ∫ÿßÿ°$"), self._cancel_gpa_calc),
                    MessageHandler(filters.TEXT & ~filters.COMMAND, self._gpa_ask_course_count)
                ],
                ASK_GPA_PERCENTAGE: [
                    MessageHandler(filters.Regex("^‚ùå ÿ•ŸÑÿ∫ÿßÿ°$"), self._cancel_gpa_calc),
                    MessageHandler(filters.TEXT & ~filters.COMMAND, self._gpa_ask_percentage)
                ],
                ASK_GPA_ECTS: [
                    MessageHandler(filters.Regex("^‚ùå ÿ•ŸÑÿ∫ÿßÿ°$"), self._cancel_gpa_calc),
                    MessageHandler(filters.TEXT & ~filters.COMMAND, self._gpa_ask_ects)
                ],
            },
            fallbacks=[
                CommandHandler("cancel", self._cancel_gpa_calc),
                MessageHandler(filters.Regex("^‚ùå ÿ•ŸÑÿ∫ÿßÿ°$"), self._cancel_gpa_calc)
            ],
            allow_reentry=True,
        )
        self.app.add_handler(gpa_calc_handler)
        # Move older_terms_handler above the generic handler
        older_terms_handler = ConversationHandler(
            entry_points=[MessageHandler(filters.Regex("^üìÖ ÿ¨ŸÖŸäÿπ ÿßŸÑŸÅÿµŸàŸÑ$"), self._older_terms_command)],
            states={
                ASK_OLDER_TERM_NUMBER: [MessageHandler(filters.TEXT & ~filters.COMMAND, self._ask_older_term_number)],
            },
            fallbacks=[MessageHandler(filters.Regex("^‚ùå ÿ•ŸÑÿ∫ÿßÿ°$"), self._cancel_registration)],
        )
        self.app.add_handler(older_terms_handler)
        # The generic handler must come after all ConversationHandlers
        self.app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self._handle_message))
        self.app.add_handler(CallbackQueryHandler(self._settings_callback_handler, pattern="^(back_to_main|cancel_action)$"))
        settings_handler = ConversationHandler(
            entry_points=[CommandHandler("settings", self._settings_command)],
            states={
                ASK_SETTINGS_MAIN: [MessageHandler(filters.Regex("^üîë ÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿ¨ŸÑÿ≥ÿ©/ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±$"), self._session_management_start)],
                ASK_SESSION_MANAGEMENT: [MessageHandler(filters.TEXT & ~filters.COMMAND, self._handle_session_management)],
            },
            fallbacks=[MessageHandler(filters.Regex("^üîô ÿßŸÑÿπŸàÿØÿ©$"), self._return_to_main)],
        )
        self.app.add_handler(settings_handler)

    async def _send_message_with_keyboard(self, update, message, keyboard_type="main"):
        keyboards = {
            "main": get_main_keyboard, 
            "admin": get_admin_keyboard, 
            "cancel": get_cancel_keyboard, 
            "unregistered": get_unregistered_keyboard,
            "error_recovery": get_error_recovery_keyboard
        }
        await update.message.reply_text(message, reply_markup=keyboards.get(keyboard_type, get_main_keyboard)())
    
    async def _send_message_without_keyboard(self, update, message):
        """Send message and remove any existing keyboard."""
        await update.message.reply_text(message, reply_markup=remove_keyboard())
    
    async def _edit_message_no_keyboard(self, message_obj, new_text):
        try: await message_obj.edit_text(new_text)
        except Exception: pass 

    async def _start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user = self.user_storage.get_user(update.effective_user.id)
        fullname = user.get('fullname') if user else None
        
        # Show user-friendly welcome message
        if user:
            # Registered user - show simple welcome with security info
            welcome_message = get_security_welcome_message()
            await self._send_message_with_keyboard(update, welcome_message, "main")
        else:
            # New user - show simple explanation
            welcome_message = get_simple_welcome_message()
            await self._send_message_with_keyboard(update, welcome_message, "unregistered")

    async def _help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        is_admin = user_id == CONFIG["ADMIN_ID"]
        help_text = (
            "üéì ÿØŸÑŸäŸÑ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ®Ÿàÿ™\n\n"
            "ŸÉŸäŸÅŸäÿ© ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ:\n"
            "1. ÿßÿ∂ÿ∫ÿ∑ 'üöÄ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ' Ÿàÿ£ÿØÿÆŸÑ ÿ®ŸäÿßŸÜÿßÿ™ŸÉ ÿßŸÑÿ¨ÿßŸÖÿπŸäÿ©\n"
            "2. ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ£ÿ≤ÿ±ÿßÿ± ŸÑŸÅÿ≠ÿµ ÿßŸÑÿØÿ±ÿ¨ÿßÿ™ ŸàÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™\n"
            "3. ÿßÿ≥ÿ™ÿπŸÖŸÑ ÿßŸÑÿ£ÿ≤ÿ±ÿßÿ± ŸÑŸÑŸÖÿ≥ÿßÿπÿØÿ© ÿ£Ÿà ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä\n\n"
            "ÿßŸÑÿ£ŸàÿßŸÖÿ± ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ©:\n"
            "/start - ÿ®ÿØÿ° ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ\n"
            "/help - ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ©\n"
            "/grades - ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿØÿ±ÿ¨ÿßÿ™ ÿßŸÑŸÅÿµŸÑ ÿßŸÑÿ≠ÿßŸÑŸä\n"
            "/old_grades - ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿØÿ±ÿ¨ÿßÿ™ ÿßŸÑŸÅÿµŸÑ ÿßŸÑÿ≥ÿßÿ®ŸÇ\n"
            "/profile - ŸÖÿπŸÑŸàŸÖÿßÿ™Ÿä\n"
            "/settings - ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™\n"
            "/support - ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä\n\n"
            "ÿ£ŸàÿßŸÖÿ± ÿßŸÑÿ£ŸÖÿßŸÜ:\n"
            "/security_info - ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ£ŸÖÿßŸÜ\n"
            "/security_audit - ÿ™ŸÇÿ±Ÿäÿ± ÿßŸÑÿ™ÿØŸÇŸäŸÇ ÿßŸÑÿ£ŸÖŸÜŸä\n"
            "/security_headers - ŸÖÿπŸÑŸàŸÖÿßÿ™ ŸÖÿπÿßŸäŸäÿ± ÿßŸÑÿ£ŸÖÿßŸÜ (ŸÑŸÑŸÖÿ∑Ÿàÿ± ŸÅŸÇÿ∑)\n"
            "/privacy_policy - ÿ≥Ÿäÿßÿ≥ÿ© ÿßŸÑÿÆÿµŸàÿµŸäÿ©\n"
        )
        if is_admin:
            help_text += "\nÿ£ŸàÿßŸÖÿ± ÿßŸÑŸÖÿØŸäÿ±:\n/security_stats - ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ£ŸÖÿßŸÜ\n/admin - ŸÑŸàÿ≠ÿ© ÿßŸÑÿ™ÿ≠ŸÉŸÖ\n"
        help_text += f"\nüë®‚Äçüíª ÿßŸÑŸÖÿ∑Ÿàÿ±: {CONFIG.get('ADMIN_USERNAME', '@admin')}"
        try:
            await update.message.reply_text(help_text)
        except Exception as e:
            logger.error(f"Error sending help message: {e}")

    async def _security_info_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            from admin.dashboard import AdminDashboard
            security_info = AdminDashboard.get_user_security_info()
            await update.message.reply_text(security_info, reply_markup=get_main_keyboard())
        except Exception as e:
            await update.message.reply_text("ÿπÿ∞ÿ±ÿßŸãÿå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿπÿ±ÿ∂ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ£ŸÖÿßŸÜ.", reply_markup=get_main_keyboard())
            logger.error(f"Error in _security_info_command: {e}", exc_info=True)

    async def _security_audit_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            audit_message = (
                "üìã ÿ™ŸÇÿ±Ÿäÿ± ÿßŸÑÿ™ÿØŸÇŸäŸÇ ÿßŸÑÿ£ŸÖŸÜŸä:\n\n"
                "‚Ä¢ ÿ¨ŸÖŸäÿπ ÿßŸÑÿπŸÖŸÑŸäÿßÿ™ ŸÅŸä ÿßŸÑÿ®Ÿàÿ™ ÿ™ÿÆÿ∂ÿπ ŸÑŸÖÿ±ÿßÿ¨ÿπÿ© ÿØŸàÿ±Ÿäÿ© ŸÑÿ∂ŸÖÿßŸÜ ÿßŸÑÿ£ŸÖÿßŸÜ.\n"
                "‚Ä¢ ŸÑÿß Ÿäÿ™ŸÖ ÿ™ÿÆÿ≤ŸäŸÜ ŸÉŸÑŸÖÿßÿ™ ÿßŸÑŸÖÿ±Ÿàÿ± ÿ£Ÿà ŸÖÿ¥ÿßÿ±ŸÉÿ™Ÿáÿß ŸÖÿπ ÿ£Ÿä ÿ¨Ÿáÿ©.\n"
                "‚Ä¢ ŸÜÿ≥ÿ™ÿÆÿØŸÖ ÿ£ÿ≠ÿØÿ´ ŸÖÿπÿßŸäŸäÿ± ÿßŸÑÿ£ŸÖÿßŸÜ ŸÑÿ≠ŸÖÿßŸäÿ© ÿ®ŸäÿßŸÜÿßÿ™ŸÉ.\n\n"
                "ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÑÿØŸäŸÉ ÿ£Ÿä ÿ≥ÿ§ÿßŸÑ ÿπŸÜ ÿßŸÑÿ£ŸÖÿßŸÜÿå ÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä."
            )
            await update.message.reply_text(audit_message, reply_markup=get_main_keyboard())
        except Exception as e:
            await update.message.reply_text("ÿπÿ∞ÿ±ÿßŸãÿå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿπÿ±ÿ∂ ÿ™ŸÇÿ±Ÿäÿ± ÿßŸÑÿ™ÿØŸÇŸäŸÇ.", reply_markup=get_main_keyboard())
            logger.error(f"Error in _security_audit_command: {e}", exc_info=True)

    async def _privacy_policy_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            privacy_message = (
                "üîí ÿ≥Ÿäÿßÿ≥ÿ© ÿßŸÑÿÆÿµŸàÿµŸäÿ©:\n\n"
                "‚Ä¢ ÿ®ŸäÿßŸÜÿßÿ™ŸÉ ÿßŸÑÿ¨ÿßŸÖÿπŸäÿ© ÿ™Ÿèÿ≥ÿ™ÿÆÿØŸÖ ŸÅŸÇÿ∑ ŸÑÿ¨ŸÑÿ® ÿßŸÑÿØÿ±ÿ¨ÿßÿ™ ŸàŸÑÿß Ÿäÿ™ŸÖ ÿ™ÿÆÿ≤ŸäŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ŸÜŸáÿßÿ¶ŸäÿßŸã.\n"
                "‚Ä¢ ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™ ŸÖÿ¥ŸÅÿ±ÿ© Ÿàÿ¢ŸÖŸÜÿ© ŸàŸÑÿß Ÿäÿ™ŸÖ ŸÖÿ¥ÿßÿ±ŸÉÿ™Ÿáÿß ŸÖÿπ ÿ£Ÿä ÿ¨Ÿáÿ© ÿÆÿßÿ±ÿ¨Ÿäÿ©.\n"
                "‚Ä¢ ŸäŸÖŸÉŸÜŸÉ ÿ≠ÿ∞ŸÅ ÿ®ŸäÿßŸÜÿßÿ™ŸÉ ŸÅŸä ÿ£Ÿä ŸàŸÇÿ™ ŸÖŸÜ ÿÆŸÑÿßŸÑ ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä.\n"
                "‚Ä¢ ŸáÿØŸÅŸÜÿß ŸáŸà ÿ≠ŸÖÿßŸäÿ© ÿÆÿµŸàÿµŸäÿ™ŸÉ Ÿàÿ™ŸÇÿØŸäŸÖ ÿ£ŸÅÿ∂ŸÑ ÿ™ÿ¨ÿ±ÿ®ÿ© ŸÖŸÖŸÉŸÜÿ©.\n\n"
                "ŸÑÿ£Ÿä ÿßÿ≥ÿ™ŸÅÿ≥ÿßÿ± ÿπŸÜ ÿßŸÑÿÆÿµŸàÿµŸäÿ©ÿå ÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä."
            )
            await update.message.reply_text(privacy_message, reply_markup=get_main_keyboard())
        except Exception as e:
            await update.message.reply_text("ÿπÿ∞ÿ±ÿßŸãÿå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿπÿ±ÿ∂ ÿ≥Ÿäÿßÿ≥ÿ© ÿßŸÑÿÆÿµŸàÿµŸäÿ©.", reply_markup=get_main_keyboard())
            logger.error(f"Error in _privacy_policy_command: {e}", exc_info=True)

    async def _security_stats_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            if update.effective_user.id != CONFIG["ADMIN_ID"]:
                await update.message.reply_text("üö´ Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÖÿ™ÿßÿ≠ ŸÑŸÑŸÖÿØŸäÿ± ŸÅŸÇÿ∑.", reply_markup=get_main_keyboard())
                return
            stats = security_manager.get_security_stats()
            
            # Support both old and new stats structures
            total_events = stats.get('total_events_24h', 0)
            failed_logins = stats.get('failed_logins', 0)
            blocked_attempts = stats.get('blocked_attempts', 0)
            active_sessions = stats.get('active_sessions', 0)
            high_risk_events = stats.get('high_risk_events', 0)
            
            # Extract nested stats if present
            if 'rate_limiter' in stats:
                blocked_attempts = stats.get('rate_limiter', {}).get('blocked_users', 0)
            if 'session_manager' in stats:
                active_sessions = stats.get('session_manager', {}).get('active_sessions', 0)
            
            stats_message = (
                "üîê ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ£ŸÖÿßŸÜ (24 ÿ≥ÿßÿπÿ©)\n\n"
                f"üìä ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑÿ£ÿ≠ÿØÿßÿ´: {total_events}\n"
                f"‚ùå ŸÖÿ≠ÿßŸàŸÑÿßÿ™ ÿ™ÿ≥ÿ¨ŸäŸÑ ŸÅÿßÿ¥ŸÑÿ©: {failed_logins}\n"
                f"üö´ ŸÖÿ≠ÿßŸàŸÑÿßÿ™ ŸÖÿ≠ÿ∏Ÿàÿ±ÿ©: {blocked_attempts}\n"
                f"üë• ÿßŸÑÿ¨ŸÑÿ≥ÿßÿ™ ÿßŸÑŸÜÿ¥ÿ∑ÿ©: {active_sessions}\n"
                f"‚ö†Ô∏è ÿ£ÿ≠ÿØÿßÿ´ ÿπÿßŸÑŸäÿ© ÿßŸÑÿÆÿ∑Ÿàÿ±ÿ©: {high_risk_events}\n\n"
                "üí° Ÿáÿ∞Ÿá ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿ™ÿ≥ÿßÿπÿØ ŸÅŸä ŸÖÿ±ÿßŸÇÿ®ÿ© ÿßŸÑÿ£ŸÖÿßŸÜ"
            )
            await update.message.reply_text(stats_message, reply_markup=get_main_keyboard())
        except Exception as e:
            await update.message.reply_text("ÿπÿ∞ÿ±ÿßŸãÿå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ¨ŸÑÿ® ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ£ŸÖÿßŸÜ.", reply_markup=get_main_keyboard())
            logger.error(f"Error in _security_stats_command: {e}", exc_info=True)

    async def _security_headers_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            headers_message = (
                "üõ°Ô∏è ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ£ŸÖÿßŸÜ:\n\n"
                "‚Ä¢ ÿßŸÑÿ®Ÿàÿ™ Ÿäÿ≥ÿ™ÿÆÿØŸÖ ÿ™ŸÇŸÜŸäÿßÿ™ ÿ≠ŸÖÿßŸäÿ© ŸÖÿ™ŸÇÿØŸÖÿ© ŸÑÿ∂ŸÖÿßŸÜ ÿ≥ÿ±Ÿäÿ© ÿ®ŸäÿßŸÜÿßÿ™ŸÉ.\n"
                "‚Ä¢ ÿ¨ŸÖŸäÿπ ÿßŸÑÿßÿ™ÿµÿßŸÑÿßÿ™ ŸÖÿ¥ŸÅÿ±ÿ© Ÿàÿ¢ŸÖŸÜÿ©.\n"
                "‚Ä¢ ŸÑÿß ÿØÿßÿπŸä ŸÑŸÑŸÇŸÑŸÇ ÿ®ÿ¥ÿ£ŸÜ ÿßŸÑÿÆÿµŸàÿµŸäÿ© ÿ£Ÿà ÿßŸÑÿ£ŸÖÿßŸÜ.\n\n"
                "ŸÑÿ£Ÿä ÿßÿ≥ÿ™ŸÅÿ≥ÿßÿ±ÿå ÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä."
            )
            await update.message.reply_text(headers_message, reply_markup=get_main_keyboard())
        except Exception as e:
            await update.message.reply_text("ÿπÿ∞ÿ±ÿßŸãÿå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ¨ŸÑÿ® ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ£ŸÖÿßŸÜ.", reply_markup=get_main_keyboard())
            logger.error(f"Error in _security_headers_command: {e}", exc_info=True)

    async def _grades_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            logger.info(f"üîç _grades_command called for user {update.effective_user.id}")
            context.user_data['last_action'] = 'grades'
            telegram_id = update.effective_user.id
            user = self.user_storage.get_user(telegram_id)
            logger.info(f"üìä User lookup result: {user is not None}")
            if not user:
                logger.warning(f"‚ùå User {telegram_id} not found in storage")
                await update.message.reply_text("‚ùóÔ∏è Ÿäÿ¨ÿ® ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ£ŸàŸÑÿßŸã.", reply_markup=get_unregistered_keyboard())
                return
            token = user.get("session_token")
            logger.info(f"üîë Token found: {token is not None}")
            if not token:
                logger.warning(f"‚ùå No token for user {telegram_id}")
                await update.message.reply_text("‚ùóÔ∏è Ÿäÿ¨ÿ® ÿ•ÿπÿßÿØÿ© ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ.", reply_markup=get_unregistered_keyboard())
                return
            
            # Test token validity first
            logger.info(f"üîç Testing token validity for user {telegram_id}")
            if not await self.university_api.test_token(token):
                logger.warning(f"‚ùå Invalid token for user {telegram_id}")
                
                # Token is invalid, force logout
                logger.warning(f"‚ùå Invalid token for user {user.get('username', 'Unknown')}, forcing logout")
                await self._force_logout_user(telegram_id, update)
                return
            
            logger.info(f"üåê Calling get_user_data for user {telegram_id}")
            user_data = await self.university_api.get_user_data(token)
            logger.info(f"üìä User data result: {user_data is not None}")
            
            # Check if user_data is None (API error) or has no grades
            if not user_data:
                logger.warning(f"‚ùå API error for user {telegram_id}, forcing logout")
                await self._force_logout_user(telegram_id, update)
                return
            
            grades = user_data.get("grades", [])
            logger.info(f"üìà Grades count: {len(grades) if grades else 0}")
            
            if not grades:
                logger.warning(f"‚ö†Ô∏è No grades found for user {telegram_id}")
                await update.message.reply_text("ŸÑÿß ŸäŸàÿ¨ÿØ ÿØÿ±ÿ¨ÿßÿ™ ŸÖÿ™ÿßÿ≠ÿ© ÿ®ÿπÿØ.", reply_markup=get_main_keyboard())
                return

            # Always save grades to the grade table after fetching
            self.grade_storage.store_grades(user.get('username'), grades)

            # Format grades with quote
            logger.info(f"üìù Formatting grades for user {telegram_id}")
            message = await self.grade_analytics.format_current_grades_with_quote(telegram_id, grades)
            logger.info(f"‚úÖ Sending formatted message to user {telegram_id}")
            await update.message.reply_text(message, parse_mode=ParseMode.MARKDOWN, reply_markup=get_main_keyboard())
        except Exception as e:
            logger.error(f"[ALERT] Error in _grades_command: {e}", exc_info=True)
            admin_id = CONFIG.get("ADMIN_ID")
            admin_username = CONFIG.get("ADMIN_USERNAME", "@admin")
            if admin_id:
                try:
                    await self.app.bot.send_message(chat_id=admin_id, text=f"[DB/UX ERROR] User: {update.effective_user.id}\nAction: grades\nError: {e}")
                except Exception:
                    pass
            is_registered = self.user_storage.is_user_registered(update.effective_user.id)
            keyboard = get_main_keyboard() if is_registered else get_unregistered_keyboard()
            await update.message.reply_text(f"‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ¨ŸÑÿ® ÿßŸÑÿØÿ±ÿ¨ÿßÿ™. ÿ•ÿ∞ÿß ÿßÿ≥ÿ™ŸÖÿ±ÿ™ ÿßŸÑŸÖÿ¥ŸÉŸÑÿ©ÿå ŸÑÿß ÿ™ÿ™ÿ±ÿØÿØ ŸÅŸä ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑŸÖÿ∑Ÿàÿ± {admin_username}.", reply_markup=keyboard)

    async def _old_grades_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            context.user_data['last_action'] = 'old_grades'
            telegram_id = update.effective_user.id
            user = self.user_storage.get_user(telegram_id)
            if not user:
                await update.message.reply_text("‚ùóÔ∏è Ÿäÿ¨ÿ® ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ£ŸàŸÑÿßŸã.", reply_markup=get_unregistered_keyboard())
                return
            token = user.get("session_token")
            if not token:
                await update.message.reply_text("‚ùóÔ∏è Ÿäÿ¨ÿ® ÿ•ÿπÿßÿØÿ© ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ.", reply_markup=get_unregistered_keyboard())
                return
            
            # Test token validity first
            logger.info(f"üîç Testing token validity for user {telegram_id} (old grades)")
            if not await self.university_api.test_token(token):
                logger.warning(f"‚ùå Invalid token for user {telegram_id}")
                
                # Token is invalid, force logout
                logger.warning(f"‚ùå Invalid token for user {user.get('username', 'Unknown')}, forcing logout")
                await self._force_logout_user(telegram_id, update)
                return
            
            old_grades = await self.university_api.get_old_grades(token)
            if old_grades is None:
                logger.warning(f"‚ùå API error for user {telegram_id} (old grades), forcing logout")
                await self._force_logout_user(telegram_id, update)
                return
            if not old_grades:
                await update.message.reply_text("üìö ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿØÿ±ÿ¨ÿßÿ™ ÿ≥ÿßÿ®ŸÇÿ© ŸÖÿ™ÿßÿ≠ÿ© ŸÑŸÑŸÅÿµŸÑ ÿßŸÑÿØÿ±ÿßÿ≥Ÿä ÿßŸÑÿ≥ÿßÿ®ŸÇ.", reply_markup=get_main_keyboard())
                return
            formatted_message = await self.grade_analytics.format_old_grades_with_analysis(telegram_id, old_grades)
            # Split long messages if needed
            if len(formatted_message) > 4096:
                # Send message in chunks if too long
                for i in range(0, len(formatted_message), 4096):
                    await update.message.reply_text(formatted_message[i:i+4096], reply_markup=get_main_keyboard())
            else:
                await update.message.reply_text(formatted_message, reply_markup=get_main_keyboard())
        except Exception as e:
            logger.error(f"[ALERT] Error in _old_grades_command: {e}", exc_info=True)
            admin_id = CONFIG.get("ADMIN_ID")
            admin_username = CONFIG.get("ADMIN_USERNAME", "@admin")
            if admin_id:
                try:
                    await self.app.bot.send_message(chat_id=admin_id, text=f"[DB/UX ERROR] User: {update.effective_user.id}\nAction: old_grades\nError: {e}")
                except Exception:
                    pass
            context.user_data.pop('last_action', None)
            is_registered = self.user_storage.is_user_registered(update.effective_user.id)
            keyboard = get_main_keyboard() if is_registered else get_unregistered_keyboard()
            await update.message.reply_text(f"‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ ÿ£ÿ´ŸÜÿßÿ° ÿ¨ŸÑÿ® ÿßŸÑÿØÿ±ÿ¨ÿßÿ™ ÿßŸÑÿ≥ÿßÿ®ŸÇÿ©. ÿ•ÿ∞ÿß ÿßÿ≥ÿ™ŸÖÿ±ÿ™ ÿßŸÑŸÖÿ¥ŸÉŸÑÿ©ÿå ŸÑÿß ÿ™ÿ™ÿ±ÿØÿØ ŸÅŸä ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑŸÖÿ∑Ÿàÿ± {admin_username}.", reply_markup=keyboard)

    async def _profile_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            telegram_id = update.effective_user.id
            user = self.user_storage.get_user(telegram_id)
            if not user:
                await update.message.reply_text("‚ùóÔ∏è Ÿäÿ¨ÿ® ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ£ŸàŸÑÿßŸã.", reply_markup=get_unregistered_keyboard())
                return
            msg = (
                f"üë§ **ŸÖÿπŸÑŸàŸÖÿßÿ™ŸÉ ÿßŸÑÿ¨ÿßŸÖÿπŸäÿ©:**\n"
                f"‚Ä¢ ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑŸÉÿßŸÖŸÑ: {user.get('fullname', '-')}\n"
                f"‚Ä¢ ÿßÿ≥ŸÖ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ¨ÿßŸÖÿπŸä: {user.get('username', '-')}\n"
            )
            try:
                await update.message.reply_text(msg, reply_markup=get_main_keyboard())
            except Exception as e:
                logger.error(f"Error sending profile message: {e}")
                await update.message.reply_text(msg, reply_markup=get_main_keyboard())
        except Exception as e:
            await update.message.reply_text("ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ¨ŸÑÿ® ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™.", reply_markup=get_unregistered_keyboard())
            logger.error(f"Error in _profile_command: {e}", exc_info=True)

    async def _settings_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await update.message.reply_text(
            "‚öôÔ∏è ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ≠ÿ≥ÿßÿ®\n\n"
            "ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ™ÿ≠ŸÉŸÖ ŸÅŸä ÿ®ŸäÿßŸÜÿßÿ™ŸÉ ŸàÿßŸÑŸàÿµŸàŸÑ ÿ•ŸÑŸâ ÿÆŸäÿßÿ±ÿßÿ™ ÿßŸÑÿÆÿµŸàÿµŸäÿ©.\n"
            "ŸÉŸÑ ÿ¥Ÿäÿ° ŸÅŸä Ÿáÿ∞ÿß ÿßŸÑÿ®Ÿàÿ™ ÿ¥ŸÅÿßŸÅ ŸàŸäŸÖŸÉŸÜŸÉ ÿØÿßÿ¶ŸÖÿßŸã ŸÖÿπÿ±ŸÅÿ© ŸÉŸäŸÅ Ÿäÿ™ŸÖ ÿßŸÑÿ™ÿπÿßŸÖŸÑ ŸÖÿπ ÿ®ŸäÿßŸÜÿßÿ™ŸÉ.\n\n"
            "- ŸäŸÖŸÉŸÜŸÉ ÿ≤Ÿäÿßÿ±ÿ© ÿßŸÑŸÉŸàÿØ ÿßŸÑÿ®ÿ±ŸÖÿ¨Ÿä ÿπŸÑŸâ GitHub.",
            reply_markup=get_session_settings_keyboard()
        )
        return ASK_SETTINGS_MAIN

    def _get_contact_support_keyboard(self):
        """Returns an inline keyboard with a Contact Support button."""
        admin_username = CONFIG.get("ADMIN_USERNAME", "@admin")
        return InlineKeyboardMarkup([
            [InlineKeyboardButton("üìû ÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä", url=f"https://t.me/{admin_username.lstrip('@')}")]
        ])

    async def _support_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            admin_username = CONFIG.get("ADMIN_USERNAME", "@admin")
            await update.message.reply_text(
                f"üìû ŸÑŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä: {admin_username}\nÿßÿ∂ÿ∫ÿ∑ ÿßŸÑÿ≤ÿ± ÿ£ÿØŸÜÿßŸá ŸÑŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿ®ÿßÿ¥ÿ±ÿ©.",
                reply_markup=self._get_contact_support_keyboard()
            )
        except Exception as e:
            await update.message.reply_text("ÿπÿ∞ÿ±ÿßŸãÿå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿπÿ±ÿ∂ ÿßŸÑÿØÿπŸÖ.", reply_markup=get_main_keyboard())
            logger.error(f"Error in _support_command: {e}", exc_info=True)

    async def _admin_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        # Show admin dashboard for admin users
        if update.effective_user.id == CONFIG["ADMIN_ID"]:
            await self.admin_dashboard.show_dashboard(update, context)
        else:
            await update.message.reply_text("üö´ ŸÑŸäÿ≥ ŸÑÿØŸäŸÉ ÿµŸÑÿßÿ≠Ÿäÿ© ŸÑŸáÿ∞Ÿá ÿßŸÑÿπŸÖŸÑŸäÿ©.", reply_markup=get_main_keyboard())

    async def _handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        text = update.message.text
        user_id = update.effective_user.id
        is_registered = self.user_storage.is_user_registered(user_id)
        if text == "‚ùå ÿ•ŸÑÿ∫ÿßÿ°":
            keyboard = get_main_keyboard() if is_registered else get_unregistered_keyboard()
            await update.message.reply_text(
                "‚úÖ ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿπŸÖŸÑŸäÿ©. ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ®ÿØÿ° ŸÖŸÜ ÿ¨ÿØŸäÿØ ÿ£Ÿà ÿßÿÆÿ™Ÿäÿßÿ± ÿ•ÿ¨ÿ±ÿßÿ° ÿ¢ÿÆÿ±.",
                reply_markup=keyboard
            )
            context.user_data.clear()
            return
        try:
            # Admin: user search
            if user_id == CONFIG["ADMIN_ID"] and context.user_data.get('awaiting_user_search'):
                handled = await self.admin_dashboard.handle_user_search_message(update, context)
                if handled:
                    context.user_data.pop('awaiting_user_search', None)
                    return
            # Admin: user delete
            if user_id == CONFIG["ADMIN_ID"] and context.user_data.get('awaiting_user_delete'):
                handled = await self.admin_dashboard.handle_user_delete_message(update, context)
                if handled:
                    context.user_data.pop('awaiting_user_delete', None)
                    return
            # Admin: broadcast
            if user_id == CONFIG["ADMIN_ID"] and context.user_data.get('awaiting_broadcast'):
                handled = await self.admin_dashboard.handle_dashboard_message(update, context)
                if handled:
                    context.user_data.pop('awaiting_broadcast', None)
                    return
            # Admin: force grade check
            if context.user_data.get("awaiting_force_grade_check"):
                handled = await self.admin_dashboard.handle_force_grade_check_message(update, context)
                if handled:
                    return
            # Handle error recovery buttons
            # If the user presses a session type button outside registration, show the welcome message and keyboard
            if text in [
                "üîí ÿ¨ŸÑÿ≥ÿ© ŸÖÿ§ŸÇÿ™ÿ© (ŸÑÿß Ÿäÿ™ŸÖ ÿ™ÿÆÿ≤ŸäŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±)",
                "üîë ÿ¨ŸÑÿ≥ÿ© ÿØÿßÿ¶ŸÖÿ© (ÿ™ÿÆÿ≤ŸäŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ŸÖÿ¥ŸÅÿ±)"
            ]:
                user = self.user_storage.get_user(user_id)
                if user:
                    from utils.messages import get_welcome_message
                    welcome_message = get_welcome_message(user.get('fullname'))
                    await update.message.reply_text(welcome_message, reply_markup=get_main_keyboard())
                else:
                    from utils.messages import get_simple_welcome_message
                    await update.message.reply_text(get_simple_welcome_message(), reply_markup=get_unregistered_keyboard())
                return
            # Map button text to actions
            actions = {
                # Grade actions
                "üìä ÿØÿ±ÿ¨ÿßÿ™ ÿßŸÑŸÅÿµŸÑ ÿßŸÑÿ≠ÿßŸÑŸä": self._grades_command,
                "üìö ÿØÿ±ÿ¨ÿßÿ™ ÿßŸÑŸÅÿµŸÑ ÿßŸÑÿ≥ÿßÿ®ŸÇ": self._old_grades_command,
                # User actions
                "üë§ ŸÖÿπŸÑŸàŸÖÿßÿ™Ÿä ÿßŸÑÿ¥ÿÆÿµŸäÿ©": self._profile_command,
                "‚öôÔ∏è ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ ŸàÿßŸÑÿ™ÿÆÿµŸäÿµ": self._settings_command,
                # Support/help
                "üìû ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä": self._support_command,
                "‚ùì ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ© ŸàÿßŸÑÿØŸÑŸäŸÑ": self._help_command,
                # Registration
                "üöÄ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÑŸÑÿ¨ÿßŸÖÿπÿ©": self._register_start,
                # Admin
                "üéõÔ∏è ŸÑŸàÿ≠ÿ© ÿßŸÑÿ™ÿ≠ŸÉŸÖ ÿßŸÑÿ•ÿØÿßÿ±Ÿäÿ©": self._admin_command,
                "üîô ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑŸàÿ≠ÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©": self._return_to_main,
                # Legacy button support
                "üìä ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿØÿ±ÿ¨ÿßÿ™ ÿßŸÑŸÅÿµŸÑ ÿßŸÑÿ≠ÿßŸÑŸä": self._grades_command,
                "üìö ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿØÿ±ÿ¨ÿßÿ™ ÿßŸÑŸÅÿµŸÑ ÿßŸÑÿ≥ÿßÿ®ŸÇ": self._old_grades_command,
                "üë§ ŸÖÿπŸÑŸàŸÖÿßÿ™Ÿä": self._profile_command,
                "‚öôÔ∏è ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™": self._settings_command,
                "üìû ÿßŸÑÿØÿπŸÖ": self._support_command,
                "‚ùì ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ©": self._help_command,
                "üöÄ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ": self._register_start,
                "üéõÔ∏è ŸÑŸàÿ≠ÿ© ÿßŸÑÿ™ÿ≠ŸÉŸÖ": self._admin_command,
                "üîô ÿßŸÑÿπŸàÿØÿ©": self._return_to_main,
                # Info about bot
                "‚ùì ŸÉŸäŸÅ ŸäÿπŸÖŸÑ ÿßŸÑÿ®Ÿàÿ™ÿü": self._how_it_works_command,
                # Logout
                "üö™ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿÆÿ±Ÿàÿ¨": self._logout_command,
                # Refresh keyboard
                "üîÑ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ£ÿ≤ÿ±ÿßÿ±": self._refresh_keyboard,
                "üßÆ ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÖÿπÿØŸÑ ÿßŸÑŸÖÿÆÿµÿµ": self._gpa_calc_start,
                "üìÖ ÿ¨ŸÖŸäÿπ ÿßŸÑŸÅÿµŸàŸÑ": self._older_terms_command,
                "üì• ÿ™ÿ≠ŸÖŸäŸÑ ŸÖÿπŸÑŸàŸÖÿßÿ™Ÿä": self._download_my_info_command,
            }
            action = actions.get(text)
            if action:
                await action(update, context)
                return
            else:
                is_registered = self.user_storage.is_user_registered(user_id)
                keyboard = get_main_keyboard() if is_registered else get_unregistered_keyboard()
                await update.message.reply_text(
                    "Ÿáÿ∞Ÿá ÿßŸÑŸÖŸäÿ≤ÿ© ŸÇŸäÿØ ÿßŸÑÿ™ÿ∑ŸàŸäÿ±. ÿ≥Ÿäÿ™ŸÖ ÿ™ŸàŸÅŸäÿ±Ÿáÿß ŸÇÿ±Ÿäÿ®ÿßŸã.\n\nüìû ŸÑŸÑŸÖÿ≥ÿßÿπÿØÿ©: ÿßÿ∂ÿ∫ÿ∑ 'üìû ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä' ÿ£Ÿà ÿßŸÑÿ≤ÿ± ÿ£ÿØŸÜÿßŸá.",
                    reply_markup=keyboard
                )
        except Exception as e:
            logger.error(f"[ALERT] Error in _handle_message: {e}", exc_info=True)
            admin_id = CONFIG.get("ADMIN_ID")
            admin_username = CONFIG.get("ADMIN_USERNAME", "@admin")
            if admin_id:
                try:
                    await self.app.bot.send_message(chat_id=admin_id, text=f"[UX ERROR] User: {user_id}\nAction: {text}\nError: {e}")
                except Exception:
                    pass
            context.user_data.clear()
            is_registered = self.user_storage.is_user_registered(user_id)
            keyboard = get_main_keyboard() if is_registered else get_unregistered_keyboard()
            await update.message.reply_text(
                f"‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ\n\n**ÿßŸÑÿ≠ŸÑŸàŸÑ:**\n‚Ä¢ ÿ¨ÿ±ÿ® ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ÿ®ÿπÿØ ŸÇŸÑŸäŸÑ\n‚Ä¢ ÿ•ÿ∞ÿß ÿßÿ≥ÿ™ŸÖÿ±ÿ™ ÿßŸÑŸÖÿ¥ŸÉŸÑÿ©ÿå ŸÑÿß ÿ™ÿ™ÿ±ÿØÿØ ŸÅŸä ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑŸÖÿ∑Ÿàÿ± {admin_username}\n‚Ä¢ ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßÿ™ÿµÿßŸÑŸÉ ÿ®ÿßŸÑÿ•ŸÜÿ™ÿ±ŸÜÿ™\n\nüìû ŸÑŸÑŸÖÿ≥ÿßÿπÿØÿ©: ÿßÿ∂ÿ∫ÿ∑ 'üìû ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä' ÿ£Ÿà ÿßŸÑÿ≤ÿ± ÿ£ÿØŸÜÿßŸá.",
                reply_markup=keyboard
            )

    async def _handle_error_recovery(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle error recovery actions from the error recovery keyboard."""
        text = update.message.text
        user_id = update.effective_user.id
        
        if text == "üîÑ ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©":
            # Retry last action if possible
            last_action = context.user_data.get('last_action')
            if last_action:
                try:
                    if last_action == "grades":
                        await self._grades_command(update, context)
                    elif last_action == "old_grades":
                        await self._old_grades_command(update, context)
                    elif last_action == "profile":
                        await self._profile_command(update, context)
                    elif last_action == "settings":
                        await self._settings_command(update, context)
                    else:
                        await self._start_command(update, context)
                except Exception as e:
                    logger.error(f"Error in retry action: {e}")
                    await update.message.reply_text(
                        "‚ùå ŸÅÿ¥ŸÑÿ™ ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÑÿßÿ≠ŸÇÿßŸã.",
                        reply_markup=get_error_recovery_keyboard()
                    )
            else:
                await self._start_command(update, context)
        
        elif text == "üè† ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©":
            await self._start_command(update, context)
        
        elif text == "üìû ÿßŸÑÿØÿπŸÖ":
            await self._support_command(update, context)
        
        elif text == "‚ùì ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ©":
            await self._help_command(update, context)

    async def _handle_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        await query.answer()
        
        # Handle admin callbacks
        if update.effective_user.id == CONFIG["ADMIN_ID"]:
            await self.admin_dashboard.handle_callback(update, context)
            return
            
        # Handle regular user callbacks
        user_id = update.effective_user.id
        user = self.user_storage.get_user_by_telegram_id(user_id)
        
        if query.data == "delete_user_data":
            if not user:
                await query.edit_message_text("‚ùóÔ∏è Ÿäÿ¨ÿ® ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ£ŸàŸÑÿßŸã.")
                return
            # Show confirmation for data deletion
            await query.edit_message_text(
                "üóëÔ∏è **ÿ≠ÿ∞ŸÅ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ¥ÿÆÿµŸäÿ©**\n\n"
                "‚ö†Ô∏è **ÿ™ÿ≠ÿ∞Ÿäÿ±**: Ÿáÿ∞ÿß ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ° ÿ≥Ÿäÿ≠ÿ∞ŸÅ:\n"
                "‚Ä¢ ÿ¨ŸÖŸäÿπ ÿ®ŸäÿßŸÜÿßÿ™ŸÉ ÿßŸÑŸÖÿÆÿ≤ŸÜÿ©\n"
                "‚Ä¢ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿßŸÑŸÖÿ¥ŸÅÿ±ÿ©\n"
                "‚Ä¢ ÿ•ÿπÿØÿßÿØÿßÿ™ŸÉ ÿßŸÑÿ¥ÿÆÿµŸäÿ©\n"
                "‚Ä¢ ÿ≥ÿ¨ŸÑ ÿßŸÑÿØÿ±ÿ¨ÿßÿ™\n\n"
                "‚ùå **ŸÑÿß ŸäŸÖŸÉŸÜ ÿßŸÑÿ™ÿ±ÿßÿ¨ÿπ ÿπŸÜ Ÿáÿ∞ÿß ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ°**\n\n"
                "ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿ®ŸäÿßŸÜÿßÿ™ŸÉÿü",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("‚úÖ ŸÜÿπŸÖÿå ÿßÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿ®ŸäÿßŸÜÿßÿ™Ÿä", callback_data="confirm_delete_data")],
                    [InlineKeyboardButton("‚ùå ÿ•ŸÑÿ∫ÿßÿ°", callback_data="cancel_delete_data")]
                ])
            )
            return
            
        elif query.data == "confirm_delete_data":
            if not user:
                await query.edit_message_text("‚ùóÔ∏è Ÿäÿ¨ÿ® ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ£ŸàŸÑÿßŸã.")
                return
            # Delete user data
            try:
                # Delete user from storage
                self.user_storage.delete_user(user["username"])
                # Delete grades
                self.grade_storage.delete_user_grades(user["username"])
                await query.edit_message_text(
                    "‚úÖ ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿ®ŸäÿßŸÜÿßÿ™ŸÉ ÿ®ŸÜÿ¨ÿßÿ≠.\n\n"
                    "ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿÆÿ±Ÿàÿ¨ŸÉ ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã. ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ÿ•ÿ∞ÿß ÿ£ÿ±ÿØÿ™.",
                    reply_markup=get_unregistered_keyboard()
                )
            except Exception as e:
                await query.edit_message_text(
                    f"‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ÿ∞ŸÅ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™: {str(e)}\n\n"
                    "Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ÿ£Ÿà ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä."
                )
            return
            
        elif query.data == "cancel_delete_data":
            # Return to privacy settings
            await query.edit_message_text(
                "ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿ≠ÿ∞ŸÅ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™.",
                reply_markup=get_privacy_settings_keyboard()
            )
            return
        
        elif query.data == "back_to_settings":
            # Return to main settings
            from utils.keyboards import get_settings_main_keyboard
            keyboard = get_settings_main_keyboard(translation_enabled=user.get("do_trans", False) if user else False)
            await query.edit_message_text(
                "ÿ™ŸÖÿ™ ÿßŸÑÿπŸàÿØÿ© ÿ•ŸÑŸâ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©.",
                reply_markup=keyboard
            )
            return
            
        # Delegate other callbacks to settings handler
        await self._settings_callback_handler(update, context)

    async def _admin_notify_grades(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if update.effective_user.id != CONFIG["ADMIN_ID"]:
            await update.message.reply_text("üö´ ŸÑŸäÿ≥ ŸÑÿØŸäŸÉ ÿµŸÑÿßÿ≠Ÿäÿ© ŸÑŸáÿ∞Ÿá ÿßŸÑÿπŸÖŸÑŸäÿ©.", reply_markup=get_main_keyboard())
            return
        await update.message.reply_text("üîÑ ÿ¨ÿßÿ±Ÿä ŸÅÿ≠ÿµ ÿßŸÑÿØÿ±ÿ¨ÿßÿ™ ŸÑÿ¨ŸÖŸäÿπ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ...")
        count = await self._notify_all_users_grades()
        await update.message.reply_text(f"‚úÖ ÿ™ŸÖ ŸÅÿ≠ÿµ ÿßŸÑÿØÿ±ÿ¨ÿßÿ™ Ÿàÿ•ÿ¥ÿπÿßÿ± {count} ŸÖÿ≥ÿ™ÿÆÿØŸÖ (ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸáŸÜÿßŸÉ ÿ™ÿ∫ŸäŸäÿ±).", reply_markup=get_main_keyboard())

    async def _grade_checking_loop(self):
        logger.info("üö¶ Entered _grade_checking_loop (unconditional)")
        try:
            await asyncio.sleep(10)
            logger.info("üö¶ Slept 10 seconds, entering infinite loop")
            while True:
                logger.info("üîî Running scheduled grade check for all users (unconditional)...")
                await self._notify_all_users_grades()
                interval = int(CONFIG.get('GRADE_CHECK_INTERVAL', 10)) * 60
                logger.info(f"üö¶ Sleeping for {interval} seconds before next check (unconditional)")
                await asyncio.sleep(interval)
        except Exception as e:
            logger.error(f"‚ùå Exception in _grade_checking_loop: {e}", exc_info=True)

    async def _notify_all_users_grades(self):
        users = self.user_storage.get_all_users()
        logger.info(f"üîç Force grade check: Found {len(users)} users in database")
        
        if not users:
            logger.warning("‚ö†Ô∏è No users found in database for grade check")
            return 0
            
        notified_count = 0
        semaphore = asyncio.Semaphore(CONFIG.get('MAX_CONCURRENT_REQUESTS', 5))
        tasks = []
        results = []

        async def check_user(user):
            async with semaphore:
                try:
                    logger.debug(f"üîç Checking grades for user: {user.get('username', 'Unknown')} (ID: {user.get('telegram_id', 'Unknown')})")
                    return await self._check_and_notify_user_grades(user)
                except Exception as e:
                    logger.error(f"‚ùå Error in parallel grade check for user {user.get('username', 'Unknown')}: {e}", exc_info=True)
                    return False

        for user in users:
            tasks.append(asyncio.create_task(check_user(user)))
        if tasks:
            results = await asyncio.gather(*tasks, return_exceptions=True)
            notified_count = sum(1 for r in results if r is True)
        
        logger.info(f"üìä Force grade check completed: {notified_count}/{len(users)} users notified")
        return notified_count

    async def _check_and_notify_user_grades(self, user):
        try:
            telegram_id = user.get("telegram_id")
            username = user.get("username")
            username_unique = user.get("username_unique")
            # Always use a valid username for grade storage
            storage_username = username_unique or username
            if not storage_username:
                logger.error(f"[ALERT] Cannot store grades: missing username for user with telegram_id={telegram_id}")
                return False
            token = user.get("session_token")
            logger.info(f"[CALL] _check_and_notify_user_grades for username={username}, username_unique={username_unique}, telegram_id={telegram_id}")
            logger.info(f"[CHECK] self.grade_storage is type: {type(self.grade_storage)}")
            lock = self._get_user_lock(username_unique)
            # --- Fix: Always initialize notified and is_pg ---
            notified = user.get("session_expired_notified", False)
            is_pg = hasattr(self.user_storage, 'update_token_expired_notified')
            async with lock:
                # Notify only once if token expired
                if not token:
                    logger.debug(f"‚ùå No token for user {username}")
                    notified = user.get("session_expired_notified", False)
                    if not notified:
                        await self.app.bot.send_message(
                            chat_id=telegram_id,
                            text="‚è∞ ÿßŸÜÿ™Ÿáÿ™ ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑÿ¨ŸÑÿ≥ÿ©\n\nÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿÆÿ±Ÿàÿ¨ ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã ŸÑÿ≠ŸÖÿßŸäÿ© ÿ≠ÿ≥ÿßÿ®ŸÉ. Ÿäÿ±ÿ¨Ÿâ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÖŸÜ ÿÆŸÑÿßŸÑ ÿ≤ÿ± 'üöÄ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÑŸÑÿ¨ÿßŸÖÿπÿ©'.",
                            reply_markup=get_unregistered_keyboard()
                        )
                        is_pg = hasattr(self.user_storage, 'update_token_expired_notified')
                        if is_pg:
                            self.user_storage.update_token_expired_notified(user["username"], True)
                        else:
                            user["session_expired_notified"] = True
                            if hasattr(self.user_storage, '_save_users'):
                                self.user_storage._save_users()
                    return False
                # Test token validity
                if not await self.university_api.test_token(token):
                    logger.warning(f"‚ùå Token expired for user {username}")
                    # Try auto-login if password is stored
                    if user.get("password_stored") and user.get("encrypted_password"):
                        try:
                            from utils.crypto import decrypt_password
                            decrypted_password = decrypt_password(user["encrypted_password"])
                            new_token = await self.university_api.login(user["username"], decrypted_password)
                            if new_token:
                                logger.info(f"üîë Auto-login successful for user {username}, updating token.")
                                # Update token in storage
                                user["token"] = new_token
                                self.user_storage.save_user(
                                    telegram_id,
                                    user["username"],
                                    new_token,
                                    user,
                                    encrypted_password=user["encrypted_password"],
                                    password_stored=True,
                                    password_consent_given=user.get("password_consent_given", True)
                                )
                                # Retry grade check with new token
                                token = new_token

                            else:
                                logger.warning(f"‚ùå Auto-login failed for user {username}")
                                return False
                        except Exception as e:
                            logger.warning(f"‚ùå Auto-login failed for user {username}")
                            return False
                    else:
                        # Token is invalid, notify user to login manually
                        if not notified:
                            await self.app.bot.send_message(
                                chat_id=telegram_id,
                                text="‚è∞ ÿßŸÜÿ™Ÿáÿ™ ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑÿ¨ŸÑÿ≥ÿ©\n\nŸäÿ±ÿ¨Ÿâ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÖŸÜ ÿÆŸÑÿßŸÑ ÿ≤ÿ± 'üöÄ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÑŸÑÿ¨ÿßŸÖÿπÿ©' ÿ´ŸÖ ÿ•ÿØÿÆÿßŸÑ ÿ®ŸäÿßŸÜÿßÿ™ŸÉ ŸÖŸÜ ÿ¨ÿØŸäÿØ. Ÿáÿ∞ÿß ÿ∑ÿ®ŸäÿπŸä ŸàŸäÿ≠ÿØÿ´ ŸÉŸÑ ŸÅÿ™ÿ±ÿ©.",
                                reply_markup=get_unregistered_keyboard()
                            )
                            if is_pg:
                                self.user_storage.update_token_expired_notified(user["username"], True)
                            else:
                                user["session_expired_notified"] = True
                                if hasattr(self.user_storage, '_save_users'):
                                    self.user_storage._save_users()
                        return False
                logger.debug(f"‚úÖ Token valid for user {username}")
                # Reset notification flag if token is valid
                if notified:
                    if is_pg:
                        self.user_storage.update_token_expired_notified(user["username"], False)
                    else:
                        # Update file storage
                        user["session_expired_notified"] = False
                        if hasattr(self.user_storage, '_save_users'):
                            self.user_storage._save_users()
                logger.debug(f"üîç Fetching user data for {username}")
                user_data = await self.university_api.get_user_data(token)
                if not user_data or "grades" not in user_data:
                    logger.info(f"No grade data available for {username} in this check.")
                    return False
                new_grades = user_data.get("grades", [])
                logger.debug(f"üìä Found {len(new_grades)} new grades for user {username}")
                # Use storage_username for grade storage
                old_grades = []
                try:
                    old_grades = self.grade_storage.get_user_grades(storage_username)
                except Exception as db_exc:
                    logger.error(f"[ALERT] Persistent DB error for user {storage_username}: {db_exc}")
                    # Alert admin
                    admin_id = CONFIG.get("ADMIN_ID")
                    if admin_id:
                        try:
                            await self.app.bot.send_message(chat_id=admin_id, text=f"[DB ERROR] Persistent DB error for user {storage_username}: {db_exc}")
                        except Exception:
                            pass
                    return False
                logger.debug(f"üìä Found {len(old_grades) if old_grades else 0} stored grades for user {storage_username}")
                
                # Get user's grade notification sensitivity setting
                user_settings = self.user_settings.get_user_settings(telegram_id)
                sensitivity = user_settings.get("notifications", {}).get("grade_sensitivity", "meaningful")
                logger.debug(f"üîç User {username_unique} grade sensitivity setting: {sensitivity}")
                
                changed_courses = self._compare_grades(old_grades, new_grades, sensitivity)
                logger.debug(f"üîç Grade comparison for {storage_username}: {len(changed_courses)} {sensitivity} changes detected")
                # Always save the grades, regardless of notification
                self.grade_storage.store_grades(storage_username, new_grades)
                if not changed_courses:
                    logger.debug(f"‚úÖ No {sensitivity} grade changes for user {storage_username}, not sending notification.")
                    return False
                
                # Create appropriate message based on sensitivity
                if sensitivity == "all":
                    message = f"üéì ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿØÿ±ÿ¨ÿßÿ™ŸÉ ŸÅŸä ÿßŸÑŸÖŸàÿßÿØ ÿßŸÑÿ™ÿßŸÑŸäÿ©:\n\n"
                elif sensitivity == "significant":
                    message = f"üéì ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿØÿ±ÿ¨ÿßÿ™ŸÉ ÿ®ÿ¥ŸÉŸÑ ŸÉÿ®Ÿäÿ± ŸÅŸä ÿßŸÑŸÖŸàÿßÿØ ÿßŸÑÿ™ÿßŸÑŸäÿ©:\n\n"
                else:  # meaningful
                    message = f"üéì ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿØÿ±ÿ¨ÿßÿ™ŸÉ ŸÅŸä ÿßŸÑŸÖŸàÿßÿØ ÿßŸÑÿ™ÿßŸÑŸäÿ©:\n\n"
                old_map = {g.get('code') or g.get('name'): g for g in old_grades if g.get('code') or g.get('name')}
                
                for grade in changed_courses:
                    name = grade.get('name', 'N/A')
                    code = grade.get('code', '-')
                    key = code if code != '-' else name
                    old = old_map.get(key, {})

                    def show_change(field, label):
                        old_val = old.get(field, '‚Äî')
                        new_val = grade.get(field, '‚Äî')
                        # Always show old and new, even if old was missing or 'ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑŸÜÿ¥ÿ±'
                        return f"{label}: {old_val} ‚Üí {new_val}" if old_val != new_val else None

                    changes = [
                        show_change('coursework', 'ÿßŸÑÿ£ÿπŸÖÿßŸÑ'),
                        show_change('final_exam', 'ÿßŸÑŸÜÿ∏ÿ±Ÿä'),
                        show_change('total', 'ÿßŸÑŸÜŸáÿßÿ¶Ÿä'),
                    ]
                    changes = [c for c in changes if c]

                    if changes:
                        message += f"üìö {name} ({code})\n" + "\n".join(changes) + "\n\n"
                
                # If we reach here, we have meaningful changes to report
                now_utc3 = datetime.now(timezone.utc) + timedelta(hours=3)
                message += f"üïí ŸàŸÇÿ™ ÿßŸÑÿ™ÿ≠ÿØŸäÿ´: {now_utc3.strftime('%Y-%m-%d %H:%M')} (UTC+3)"
                await self.app.bot.send_message(chat_id=telegram_id, text=message)
                logger.info(f"‚úÖ Sent grade change notification to user {username_unique}")
                return True
        except Exception as e:
            logger.error(f"‚ùå Error in _check_and_notify_user_grades for user {user.get('username', 'Unknown')}: {e}", exc_info=True)
            return False

    def _compare_grades(self, old_grades: List[Dict], new_grades: List[Dict], sensitivity: str = "meaningful") -> List[Dict]:
        """
        Return only courses where important fields (total, coursework, final_exam) changed based on sensitivity level.
        
        Sensitivity levels:
        - "all": Notify about any change, including new courses and "ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑŸÜÿ¥ÿ±" changes
        - "meaningful": Only notify about actual grade changes (default)
        - "significant": Only notify about significant grade changes (e.g., letter grade changes)
        """
        def extract_relevant(grade):
            return {
                'code': grade.get('code') or grade.get('name'),
                'total': grade.get('total'),
                'coursework': grade.get('coursework'),
                'final_exam': grade.get('final_exam'),
            }
        
        def is_meaningful_grade(value):
            """Check if a grade value is meaningful (not empty, None, or 'ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑŸÜÿ¥ÿ±')"""
            if not value or value == 'ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑŸÜÿ¥ÿ±' or value == '‚Äî' or value == '-':
                return False
            return True
        
        def has_meaningful_change(old_val, new_val):
            """Check if there's a meaningful change between two grade values"""
            old_meaningful = is_meaningful_grade(old_val)
            new_meaningful = is_meaningful_grade(new_val)
            
            # If both are not meaningful, no change
            if not old_meaningful and not new_meaningful:
                return False
            
            # If one is meaningful and the other isn't, that's a change
            if old_meaningful != new_meaningful:
                return True
            
            # If both are meaningful, check if they're different
            if old_meaningful and new_meaningful:
                return old_val != new_val
            
            return False
        
        def has_significant_change(old_val, new_val):
            """Check if there's a significant change between two grade values (e.g., letter grade changes)"""
            if not is_meaningful_grade(old_val) or not is_meaningful_grade(new_val):
                return False
            
            # Try to extract numeric values for comparison
            try:
                old_num = float(old_val) if old_val.replace('.', '').replace('-', '').isdigit() else None
                new_num = float(new_val) if new_val.replace('.', '').replace('-', '').isdigit() else None
                
                if old_num is not None and new_num is not None:
                    # Consider significant if difference is >= 5 points
                    return abs(new_num - old_num) >= 5
                else:
                    # For letter grades, any change is significant
                    return old_val != new_val
            except:
                # If we can't parse as numbers, treat as letter grades
                return old_val != new_val
        
        old_map = {g.get('code') or g.get('name'): extract_relevant(g) for g in old_grades if g.get('code') or g.get('name')}
        changed = []
        
        for new_grade in new_grades:
            key = new_grade.get('code') or new_grade.get('name')
            if not key:
                continue
                
            relevant_new = extract_relevant(new_grade)
            relevant_old = old_map.get(key)
            
            # Handle new courses based on sensitivity
            if relevant_old is None:
                if sensitivity == "all":
                    logger.debug(f"üìù New course '{key}' found, including in changes (sensitivity: all)")
                    changed.append(new_grade)
                else:
                    logger.debug(f"üìù New course '{key}' found, skipping notification (sensitivity: {sensitivity})")
                continue
            
            # Choose comparison function based on sensitivity
            if sensitivity == "all":
                def compare_func(old_val, new_val):
                    return old_val != new_val
            elif sensitivity == "significant":
                compare_func = has_significant_change
            else:  # "meaningful" (default)
                compare_func = has_meaningful_change
            
            # Check for changes in any of the important fields
            total_changed = compare_func(relevant_old.get('total'), relevant_new.get('total'))
            coursework_changed = compare_func(relevant_old.get('coursework'), relevant_new.get('coursework'))
            final_exam_changed = compare_func(relevant_old.get('final_exam'), relevant_new.get('final_exam'))
            
            has_changes = total_changed or coursework_changed or final_exam_changed
            
            if has_changes:
                logger.debug(f"üìä {sensitivity.capitalize()} change detected for course '{key}': total={total_changed}, coursework={coursework_changed}, final_exam={final_exam_changed}")
                changed.append(new_grade)
            else:
                logger.debug(f"‚úÖ No {sensitivity} changes for course '{key}'")
        
        return changed

    async def _register_start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        
        # Rate limiting
        if not security_manager.check_login_attempt(user_id):
            await update.message.reply_text(
                "üö´ ÿ™ŸÖ ÿ≠ÿ∏ÿ± ŸÖÿ≠ÿßŸàŸÑÿßÿ™ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÖÿ§ŸÇÿ™ÿßŸã ÿ®ÿ≥ÿ®ÿ® ŸÉÿ´ÿ±ÿ© ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿßÿ™ ÿßŸÑŸÅÿßÿ¥ŸÑÿ©.\n"
                "Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ÿ®ÿπÿØ 15 ÿØŸÇŸäŸÇÿ©.",
                reply_markup=get_unregistered_keyboard()
            )
            return ConversationHandler.END
        
        # Clear previous session and user data
        existing_user = self.user_storage.get_user(user_id)
        if existing_user:
            logger.info(f"User {user_id} is relogging in. Clearing existing session.")
            # Invalidate session
            if hasattr(security_manager, 'session_manager'):
                security_manager.session_manager.invalidate_session(user_id)
            # Clear user data from context
            context.user_data.clear()
            # Remove user token
            if hasattr(self.user_storage, 'clear_user_token'):
                # For PostgreSQL storage
                self.user_storage.clear_user_token(user_id)
            else:
                # For file storage
                existing_user["token"] = None
                existing_user["token_expired_notified"] = False
                if hasattr(self.user_storage, '_save_users'):
                    self.user_storage._save_users()
        
        # Show security info before asking for credentials
        await update.message.reply_text(get_credentials_security_info_message())
        
        await update.message.reply_text(
            "Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ÿßŸÑŸÉŸàÿØ ÿßŸÑÿ¨ÿßŸÖÿπŸä ÿßŸÑÿÆÿßÿµ ÿ®ŸÉ. ÿ•ÿ∞ÿß ÿßÿ≠ÿ™ÿ¨ÿ™ ŸÑŸÑŸÖÿ≥ÿßÿπÿØÿ©ÿå ÿßÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ '‚ùì ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ©'."
        )
        return ASK_USERNAME

    async def _register_username(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        username = update.message.text.strip()
        
        # Validate username length
        if not is_valid_length(username, min_len=7, max_len=20):
            await update.message.reply_text(
                "‚ùå ÿßŸÑŸÉŸàÿØ ÿßŸÑÿ¨ÿßŸÖÿπŸä Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿ®ŸäŸÜ 7 Ÿà 20 ÿ≠ÿ±ŸÅ.\n\n"
                "‚ùå University code must be between 7 and 20 characters."
            )
            return ASK_USERNAME
        
        # Validate university code format
        if not re.fullmatch(r"[A-Za-z]{3,}[0-9]{4,}", username):
            await update.message.reply_text(
                "‚ùå ÿßŸÑŸÉŸàÿØ ÿßŸÑÿ¨ÿßŸÖÿπŸä Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿπŸÑŸâ ÿßŸÑÿ¥ŸÉŸÑ: 3 ÿ£ÿ≠ÿ±ŸÅ ÿ£Ÿà ÿ£ŸÉÿ´ÿ± ÿ´ŸÖ 4 ÿ£ÿ±ŸÇÿßŸÖ ÿ£Ÿà ÿ£ŸÉÿ´ÿ± (ŸÖÿ´ÿßŸÑ: ENG2425041).\n\n"
                "‚ùå University code must be in the form: 3+ letters then 4+ digits (e.g., ENG2425041)."
            )
            return ASK_USERNAME
        
        context.user_data['username'] = username
        await update.message.reply_text("Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±:")
        await update.message.reply_text(
            "üîí ŸÖŸÑÿßÿ≠ÿ∏ÿ©: ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ŸÑÿß ÿ™ŸèÿÆÿ≤ŸÜ ŸÜŸáÿßÿ¶ŸäÿßŸã Ÿàÿ™Ÿèÿ≥ÿ™ÿÆÿØŸÖ ŸÅŸÇÿ∑ ŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ. ÿ®ŸäÿßŸÜÿßÿ™ŸÉ ÿ¢ŸÖŸÜÿ© ÿ®ÿßŸÑŸÉÿßŸÖŸÑ.\n"
            "ŸÜÿ≥ÿ™ÿÆÿØŸÖ ÿ±ŸÖÿ≤ ÿØÿÆŸàŸÑ ŸÖÿ§ŸÇÿ™ (Token) ÿ®ÿØŸÑÿßŸã ŸÖŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ŸÑÿ≠ŸÖÿßŸäÿ© ÿ≠ÿ≥ÿßÿ®ŸÉ.\n"
            "_Note: Your password is never stored and is used only for login. Your data is fully secure._\n"
            "We use a temporary login token instead of your password to keep your account safe."
        )
        return ASK_PASSWORD

    async def _register_password(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        username = context.user_data.get('username')
        password = update.message.text.strip()
        telegram_id = update.effective_user.id
        # Make sure username is set
        if not username:
            await update.message.reply_text(
                "‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.",
                reply_markup=get_unregistered_keyboard()
            )
            return ConversationHandler.END
        # Validate password
        if not is_valid_length(password, min_len=1, max_len=100):
            await update.message.reply_text(
                "‚ùå ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©.\n\n"
                "‚ùå Invalid password format."
            )
            return ASK_PASSWORD
        # Check for invalid password characters
        if any(char in password for char in ['<', '>', '"', "'", '&', ';', '|', '`', '$', '(', ')', '{', '}']):
            await update.message.reply_text(
                "‚ùå ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿ™ÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿ±ŸÖŸàÿ≤ ÿ∫Ÿäÿ± ŸÖÿ≥ŸÖŸàÿ≠ÿ©.\n\n"
                "‚ùå Password contains invalid characters."
            )
            return ASK_PASSWORD
        # Store password in context for later use
        context.user_data['password'] = password
        # Prompt for session type with detailed explanation
        session_keyboard = ReplyKeyboardMarkup([
            ["üîí ÿ¨ŸÑÿ≥ÿ© ŸÖÿ§ŸÇÿ™ÿ© (ŸÑÿß Ÿäÿ™ŸÖ ÿ™ÿÆÿ≤ŸäŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±)", "üîë ÿ¨ŸÑÿ≥ÿ© ÿØÿßÿ¶ŸÖÿ© (ÿ™ÿÆÿ≤ŸäŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ŸÖÿ¥ŸÅÿ±)"]
        ], resize_keyboard=True, one_time_keyboard=True)
        await update.message.reply_text(
            "üîê **ÿÆŸäÿßÿ±ÿßÿ™ ÿßŸÑÿ¨ŸÑÿ≥ÿ©**\n\n"
            "ŸäŸÖŸÉŸÜŸÉ ÿßÿÆÿ™Ÿäÿßÿ± ŸÜŸàÿπ ÿßŸÑÿ¨ŸÑÿ≥ÿ© ÿßŸÑÿ™Ÿä ÿ™ŸÜÿßÿ≥ÿ®ŸÉ ÿ®ÿπÿØ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ:\n\n"
            "1Ô∏è‚É£ **ÿ¨ŸÑÿ≥ÿ© ŸÖÿ§ŸÇÿ™ÿ©**\n"
            "- ÿ≥ÿ™ÿ™ŸàŸÇŸÅ ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑÿØÿ±ÿ¨ÿßÿ™ ÿßŸÑÿ¨ÿØŸäÿØÿ© ÿ®ÿπÿØ ŸÅÿ™ÿ±ÿ© ÿ≤ŸÖŸÜŸäÿ© ŸÇÿµŸäÿ±ÿ©.\n"
            "- ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ŸÑŸÜ Ÿäÿ™ŸÖ ÿ™ÿÆÿ≤ŸäŸÜŸáÿß ÿ£ÿ®ÿØÿßŸã ÿ®ÿπÿØ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ.\n"
            "- ÿπŸÜÿØ ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑÿ¨ŸÑÿ≥ÿ© ÿ£Ÿà ÿßŸÜÿ™Ÿáÿßÿ° ÿµŸÑÿßÿ≠Ÿäÿ© ÿ±ŸÖÿ≤ ÿßŸÑÿØÿÆŸàŸÑÿå ÿ≥ÿ™ÿ≠ÿ™ÿßÿ¨ ŸÑÿ•ÿπÿßÿØÿ© ÿ•ÿØÿÆÿßŸÑ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ŸäÿØŸàŸäŸãÿß ŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.\n"
            "- ÿ≥ŸäŸÇŸàŸÖ ÿßŸÑŸÜÿ∏ÿßŸÖ ÿßŸÑÿ¨ÿßŸÖÿπŸä ÿ®ÿ™ÿ≥ÿ¨ŸäŸÑ ÿÆÿ±Ÿàÿ¨ŸÉ ÿÆÔªªŸÑ ÿ®ÿ∂ÿπÿ© ÿ£ŸäÿßŸÖ ŸàŸÑŸÜ ÿ™ÿ≥ÿ™ŸÖÿ± ÿ®ÿ™ŸÑŸÇŸä ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑÿØÿ±ÿ¨ÿßÿ™ "
            "2Ô∏è‚É£ **ÿ¨ŸÑÿ≥ÿ© ÿØÿßÿ¶ŸÖÿ©**\n"
            "- ÿ≥Ÿäÿ±ÿ≥ŸÑ ÿßŸÑÿ®Ÿàÿ™ ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑÿØÿ±ÿ¨ÿßÿ™ ÿßŸÑÿ¨ÿØŸäÿØÿ© ÿ®ÿ¥ŸÉŸÑ ŸÖÿ≥ÿ™ŸÖÿ± ŸàÿØÿßÿ¶ŸÖ.\n"
            "- ÿ≥Ÿäÿ™ŸÖ ÿ™ÿÆÿ≤ŸäŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿ®ÿ¥ŸÉŸÑ ŸÖÿ¥ŸÅÿ± Ÿàÿ¢ŸÖŸÜ (ŸÑÿß ŸäŸÖŸÉŸÜ ŸÑÿ£Ÿä ÿ¥ÿÆÿµ ÿßŸÑÿßÿ∑ŸÑÿßÿπ ÿπŸÑŸäŸáÿß).\n"
            "- ÿπŸÜÿØ ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑÿ¨ŸÑÿ≥ÿ© ÿ£Ÿà ÿßŸÜÿ™Ÿáÿßÿ° ÿµŸÑÿßÿ≠Ÿäÿ© ÿ±ŸÖÿ≤ ÿßŸÑÿØÿÆŸàŸÑÿå ÿ≥ŸäŸÇŸàŸÖ ÿßŸÑÿ®Ÿàÿ™ ÿ®ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß ÿØŸàŸÜ ÿßŸÑÿ≠ÿßÿ¨ÿ© ŸÑÿ•ÿπÿßÿØÿ© ÿ•ÿØÿÆÿßŸÑ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±.\n"
            "- Ÿáÿ∞ÿß ÿßŸÑÿÆŸäÿßÿ± ŸÖŸÜÿßÿ≥ÿ® ÿ•ÿ∞ÿß ŸÉŸÜÿ™ ÿ™ÿ±ŸäÿØ ÿ≥ŸáŸàŸÑÿ© ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸàÿπÿØŸÖ ÿßŸÑÿ≠ÿßÿ¨ÿ© ŸÑÿ•ÿØÿÆÿßŸÑ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ŸÉŸÑ ŸÖÿ±ÿ©.\n\n"
            "\nŸäÿ±ÿ¨Ÿâ ÿßÿÆÿ™Ÿäÿßÿ± ÿ£ÿ≠ÿØ ÿßŸÑÿÆŸäÿßÿ±ÿßÿ™ ŸÖŸÜ ÿßŸÑÿ£ÿ≤ÿ±ÿßÿ± ÿ£ÿØŸÜÿßŸá:",
            reply_markup=session_keyboard
        )
        return ASK_SESSION_TYPE

    async def _register_session_type(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        text = update.message.text.strip()
        if "ŸÖÿ§ŸÇÿ™ÿ©" in text:
            # Temporary session: do not store password
            context.user_data['session_type'] = 'temporary'
            context.user_data['password_stored'] = False
            context.user_data['password_consent_given'] = False
            return await self._register_login_and_fetch_info(update, context)
        elif "ÿØÿßÿ¶ŸÖÿ©" in text:
            # Permanent session: ask for password confirmation
            context.user_data['session_type'] = 'permanent'
            await update.message.reply_text(
                "Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÑŸÑÿ™ÿ£ŸÉŸäÿØ (ŸÑŸÜ Ÿäÿ™ŸÖ ÿπÿ±ÿ∂Ÿáÿß ŸÑÿ£Ÿä ÿ¥ÿÆÿµ):",
                reply_markup=ReplyKeyboardMarkup([["‚ùå ÿ•ŸÑÿ∫ÿßÿ°"]], resize_keyboard=True, one_time_keyboard=True)
            )
            context.user_data['password_confirm_attempts'] = 0
            return ASK_PASSWORD_CONFIRM
        else:
            await update.message.reply_text(
                "‚ùå Ÿäÿ±ÿ¨Ÿâ ÿßÿÆÿ™Ÿäÿßÿ± ÿ£ÿ≠ÿØ ÿßŸÑÿÆŸäÿßÿ±ÿßÿ™ ŸÖŸÜ ÿßŸÑÿ£ÿ≤ÿ±ÿßÿ± ŸÅŸÇÿ∑.",
                reply_markup=ReplyKeyboardMarkup([
                    ["üîí ÿ¨ŸÑÿ≥ÿ© ŸÖÿ§ŸÇÿ™ÿ© (ŸÑÿß Ÿäÿ™ŸÖ ÿ™ÿÆÿ≤ŸäŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±)", "üîë ÿ¨ŸÑÿ≥ÿ© ÿØÿßÿ¶ŸÖÿ© (ÿ™ÿÆÿ≤ŸäŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ŸÖÿ¥ŸÅÿ±)"]
                ], resize_keyboard=True, one_time_keyboard=True)
            )
            return ASK_SESSION_TYPE

    async def _register_password_confirm(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        password = context.user_data.get('password')
        confirm = update.message.text.strip()
        attempts = context.user_data.get('password_confirm_attempts', 0) + 1
        context.user_data['password_confirm_attempts'] = attempts
        if confirm != password:
            if attempts >= 3:
                await update.message.reply_text(
                    "‚ùå ÿ™ŸÖ ÿ•ÿØÿÆÿßŸÑ ŸÉŸÑŸÖÿ© ŸÖÿ±Ÿàÿ± ÿÆÿßÿ∑ÿ¶ÿ© 3 ŸÖÿ±ÿßÿ™. ÿ≥Ÿäÿ™ŸÖ ÿßŸÑÿ™ÿ≠ŸàŸäŸÑ ÿ•ŸÑŸâ ÿ¨ŸÑÿ≥ÿ© ŸÖÿ§ŸÇÿ™ÿ©.",
                    reply_markup=ReplyKeyboardMarkup([
                        ["üîí ÿ¨ŸÑÿ≥ÿ© ŸÖÿ§ŸÇÿ™ÿ© (ŸÑÿß Ÿäÿ™ŸÖ ÿ™ÿÆÿ≤ŸäŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±)"]
                    ], resize_keyboard=True, one_time_keyboard=True)
                )
                context.user_data['session_type'] = 'temporary'
                context.user_data['password_stored'] = False
                context.user_data['password_consent_given'] = False
                return await self._register_login_and_fetch_info(update, context)
            else:
                await update.message.reply_text(
                    f"‚ùå ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿ∫Ÿäÿ± ŸÖÿ™ÿ∑ÿßÿ®ŸÇÿ©. ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ. (ŸÖÿ≠ÿßŸàŸÑÿ© {attempts}/3)",
                    reply_markup=ReplyKeyboardMarkup([["‚ùå ÿ•ŸÑÿ∫ÿßÿ°"]], resize_keyboard=True, one_time_keyboard=True)
                )
                return ASK_PASSWORD_CONFIRM
        # Passwords match, proceed
        context.user_data['password_stored'] = True
        context.user_data['password_consent_given'] = True
        return await self._register_login_and_fetch_info(update, context)

    async def _register_login_and_fetch_info(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        username = context.user_data.get('username')
        password = context.user_data.get('password')
        session_type = context.user_data.get('session_type', 'temporary')
        telegram_id = update.effective_user.id
        # Try to log in with university API
        await update.message.reply_text("üîÑ ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ®ŸäÿßŸÜÿßÿ™ŸÉ...\nChecking your credentials...")
        token = await self.university_api.login(username, password)
        # Record login attempt
        success = token is not None
        security_manager.record_login_attempt(telegram_id, success, username)
        if not token:
            await update.message.reply_text(
                "‚ùå ÿ™ÿπÿ∞Ÿëÿ± ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿµÿ≠ÿ© ÿßÿ≥ŸÖ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸàŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿßŸÑÿ¨ÿßŸÖÿπŸäÿ© Ÿàÿ•ÿπÿßÿØÿ© ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©.\n\nLogin failed. Please check your university username and password and try again.",
                reply_markup=get_unregistered_keyboard()
            )
            return await self._register_start(update, context)
        # Get user info for welcome message
        user_info = await self.university_api.get_user_info(token)
        if user_info:
            api_fullname = user_info.get('fullname', '')
            api_firstname = user_info.get('firstname', '')
            api_lastname = user_info.get('lastname', '')
            api_username = user_info.get('username', username)
            email = user_info.get('email', '-')
            if api_fullname and api_fullname.strip():
                fullname = api_fullname.strip()
                if api_firstname and api_firstname.strip():
                    firstname = api_firstname.strip()
                    lastname = api_lastname.strip() if api_lastname else ''
                else:
                    name_parts = fullname.split()
                    if len(name_parts) >= 2:
                        firstname = name_parts[0]
                        lastname = ' '.join(name_parts[1:])
                    else:
                        firstname = fullname
                        lastname = ''
            else:
                fullname = f"ÿ∑ÿßŸÑÿ® ÿ¨ÿßŸÖÿπÿ© ÿßŸÑÿ¥ÿßŸÖ ({api_username})"
                firstname = "ÿ∑ÿßŸÑÿ®"
                lastname = "ÿ¨ÿßŸÖÿπÿ© ÿßŸÑÿ¥ÿßŸÖ"
        else:
            fullname = f"ÿ∑ÿßŸÑÿ® ÿ¨ÿßŸÖÿπÿ© ÿßŸÑÿ¥ÿßŸÖ ({username})"
            firstname = "ÿ∑ÿßŸÑÿ®"
            lastname = "ÿ¨ÿßŸÖÿπÿ© ÿßŸÑÿ¥ÿßŸÖ"
            email = '-'
        context.user_data['user_data'] = {
            "username": username,
            "fullname": fullname,
            "firstname": firstname,
            "lastname": lastname,
            "email": email
        }
        context.user_data['token'] = token
        return await self._complete_registration(update, context)

    async def _complete_registration(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        telegram_id = update.effective_user.id
        user_data = context.user_data.get('user_data')
        token = context.user_data.get('token')
        password = context.user_data.get('password')
        password_stored = context.user_data.get('password_stored', False)
        password_consent_given = context.user_data.get('password_consent_given', False)
        session_type = context.user_data.get('session_type', 'temporary')
        if not user_data or not token:
            await update.message.reply_text(
                "‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.",
                reply_markup=get_unregistered_keyboard()
            )
            return ConversationHandler.END
        # Encrypt password if permanent session
        encrypted_password = None
        if password_stored and password:
            from utils.crypto import encrypt_password
            try:
                encrypted_password = encrypt_password(password)
                logger.info("‚úÖ Password encrypted successfully")
            except Exception as e:
                logger.error(f"‚ùå Error encrypting password: {e}")
                logger.info("üîÑ Continuing with temporary session due to encryption failure")
                await update.message.reply_text(
                    "‚ö†Ô∏è ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ¥ŸÅŸäÿ± ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±. ÿ≥Ÿäÿ™ŸÖ ÿßŸÑŸÖÿ™ÿßÿ®ÿπÿ© ÿ®ÿ¨ŸÑÿ≥ÿ© ŸÖÿ§ŸÇÿ™ÿ©.",
                    reply_markup=get_unregistered_keyboard()
                )
                password_stored = False
                password_consent_given = False
        # Save user to database
        try:
            user_dict = {
                "telegram_id": telegram_id,
                "username": user_data['username'],
                "fullname": user_data.get('fullname'),
                "firstname": user_data.get('firstname'),
                "lastname": user_data.get('lastname'),
                "email": user_data.get('email'),
                "session_token": token,
                "token_expires_at": None,  # Set if you have it
                "is_active": True,
                # Optionally add encrypted_password, password_stored, password_consent_given if your User model supports them
            }
            success = self.user_storage.create_user(user_dict)
            if not success:
                # User exists, update their info
                self.user_storage.update_user(user_data['username'], {
                    "session_token": token,
                    "token_expires_at": None,
                    "is_active": True,
                    "fullname": user_data.get('fullname'),
                    "firstname": user_data.get('firstname'),
                    "lastname": user_data.get('lastname'),
                    "email": user_data.get('email'),
                    "encrypted_password": encrypted_password,
                    "password_stored": password_stored,
                    "password_consent_given": password_consent_given
                })
                logger.warning(f"User {user_data['username']} already exists, updated session info.")
                welcome_message = get_welcome_message(user_data['fullname'])
                if session_type == 'permanent' and password_stored:
                    welcome_message += "\n\nüîë **ÿ¨ŸÑÿ≥ÿ© ÿØÿßÿ¶ŸÖÿ©**\nŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ŸÖÿÆÿ≤ŸÜÿ© ÿ®ÿ¥ŸÉŸÑ ŸÖÿ¥ŸÅÿ±. ÿ≥Ÿäÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã ÿπŸÜÿØ ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑÿ¨ŸÑÿ≥ÿ©."
                else:
                    welcome_message += "\n\nüîê **ÿ¨ŸÑÿ≥ÿ© ŸÖÿ§ŸÇÿ™ÿ©**\nŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ŸÑŸÖ ÿ™ŸèÿÆÿ≤ŸÜ. ÿ≥ÿ™ÿ≠ÿ™ÿßÿ¨ ŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ÿπŸÜÿØ ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑÿ¨ŸÑÿ≥ÿ©."
                try:
                    await update.message.reply_text(welcome_message, reply_markup=get_main_keyboard())
                except Exception as e:
                    logger.error(f"Error sending welcome message: {e}")
                    await update.message.reply_text(welcome_message)
                return ConversationHandler.END
            logger.info(f"‚úÖ User saved successfully")
        except Exception as e:
            logger.error(f"‚ùå Error saving user: {e}", exc_info=True)
            await update.message.reply_text(
                "‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ŸÅÿ∏ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.",
                reply_markup=get_unregistered_keyboard()
            )
            return ConversationHandler.END
        # Create session
        try:
            security_manager.create_user_session(telegram_id, token, user_data)
            logger.info(f"‚úÖ User session created successfully")
        except Exception as e:
            logger.error(f"‚ùå Error creating user session: {e}", exc_info=True)
        # Show welcome message
        welcome_message = get_welcome_message(user_data['fullname'])
        if session_type == 'permanent' and password_stored:
            welcome_message += "\n\nüîë **ÿ¨ŸÑÿ≥ÿ© ÿØÿßÿ¶ŸÖÿ©**\nŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ŸÖÿÆÿ≤ŸÜÿ© ÿ®ÿ¥ŸÉŸÑ ŸÖÿ¥ŸÅÿ±. ÿ≥Ÿäÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã ÿπŸÜÿØ ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑÿ¨ŸÑÿ≥ÿ©."
        else:
            welcome_message += "\n\nüîê **ÿ¨ŸÑÿ≥ÿ© ŸÖÿ§ŸÇÿ™ÿ©**\nŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ŸÑŸÖ ÿ™ŸèÿÆÿ≤ŸÜ. ÿ≥ÿ™ÿ≠ÿ™ÿßÿ¨ ŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ÿπŸÜÿØ ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑÿ¨ŸÑÿ≥ÿ©."
        try:
            await update.message.reply_text(welcome_message, reply_markup=get_main_keyboard())
        except Exception as e:
            logger.error(f"Error sending welcome message: {e}")
            await update.message.reply_text(welcome_message)
        return ConversationHandler.END

    async def _return_to_main(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Return to main keyboard from admin interface"""
        keyboard_to_show = get_main_keyboard() if self.user_storage.is_user_registered(update.effective_user.id) else get_unregistered_keyboard()
        await update.message.reply_text(
            "ÿ™ŸÖÿ™ ÿßŸÑÿπŸàÿØÿ© ÿ•ŸÑŸâ ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©.",
            reply_markup=keyboard_to_show
        )

    async def _cancel_registration(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        is_registered = self.user_storage.is_user_registered(update.effective_user.id)
        keyboard = get_main_keyboard() if is_registered else get_unregistered_keyboard()
        await update.message.reply_text("ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ.", reply_markup=keyboard)
        return ConversationHandler.END

    async def send_quote_to_all_users(self, message):
        users = self.user_storage.get_all_users()
        sent = 0
        for user in users:
            try:
                await self.app.bot.send_message(chat_id=user['telegram_id'], text=message)
                sent += 1
            except Exception:
                continue
        return sent

    async def scheduled_daily_quote_broadcast(self):
        """Send daily quote to all users at scheduled time"""
        import pytz
        from datetime import datetime, time, timedelta
        tz = pytz.timezone('Asia/Riyadh')
        # Get schedule from environment
        def get_scheduled_time():
            time_str = os.getenv("QUOTE_SCHEDULE", "14:00")
            try:
                hour, minute = map(int, time_str.strip().split(":"))
                if 0 <= hour < 24 and 0 <= minute < 60:
                    return hour, minute
            except Exception:
                pass
            return 14, 0  # default time
        target_hour, target_minute = get_scheduled_time()
        logger.info(f"üïë Daily quote scheduler started (UTC+3) at {target_hour:02d}:{target_minute:02d}")
        while self.running:
            now = datetime.now(tz)
            next_run = now.replace(hour=target_hour, minute=target_minute, second=0, microsecond=0)
            if now >= next_run:
                next_run += timedelta(days=1)
            wait_seconds = (next_run - now).total_seconds()
            logger.info(f"Next daily quote broadcast in {wait_seconds/60:.1f} minutes")
            await asyncio.sleep(wait_seconds)
            if not self.running:
                break
            # Fetch and send the quote
            quote = await self.grade_analytics.get_daily_quote()
            if quote:
                user = self.user_storage.get_user_by_telegram_id(telegram_id)
                do_translate = user.get("do_trans", False) if user else False
                quote_text = await self.grade_analytics.format_quote_dual_language(quote, do_translate=do_translate)
            else:
                message = "üí¨ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸäŸàŸÖ:\n\nŸÑŸÖ ÿ™ÿ™ŸàŸÅÿ± ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸäŸàŸÖ ÿ≠ÿßŸÑŸäÿßŸã."
            count = await self.send_quote_to_all_users(message)
            logger.info(f"‚úÖ ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸäŸàŸÖ ÿ•ŸÑŸâ {count} ŸÖÿ≥ÿ™ÿÆÿØŸÖ.")

    async def _how_it_works_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await update.message.reply_text(
            "ü§ñ Ÿáÿ∞ÿß ÿßŸÑÿ®Ÿàÿ™ Ÿäÿ≥ÿßÿπÿØŸÉ ŸÅŸä ŸÖÿ™ÿßÿ®ÿπÿ© ÿØÿ±ÿ¨ÿßÿ™ŸÉ ÿßŸÑÿ¨ÿßŸÖÿπŸäÿ© ÿ®ÿ≥ŸáŸàŸÑÿ© Ÿàÿ£ŸÖÿßŸÜ!\n\n"
            "‚Ä¢ ŸäŸÖŸÉŸÜŸÉ ŸÖÿπÿ±ŸÅÿ© ÿØÿ±ÿ¨ÿßÿ™ŸÉ ÿßŸÑÿ≠ÿßŸÑŸäÿ© ŸàÿßŸÑÿ≥ÿßÿ®ŸÇÿ© ŸÅŸä ÿ£Ÿä ŸàŸÇÿ™\n"
            "‚Ä¢ ÿ™ÿµŸÑŸÉ ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ŸÅŸàÿ±Ÿäÿ© ÿπŸÜÿØ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿØÿ±ÿ¨ÿßÿ™\n"
            "‚Ä¢ ŸÉŸÑ ÿ®ŸäÿßŸÜÿßÿ™ŸÉ ŸÖÿ¥ŸÅÿ±ÿ© Ÿàÿ¢ŸÖŸÜÿ© ŸàŸÑÿß Ÿäÿ™ŸÖ ÿ™ÿÆÿ≤ŸäŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±\n"
            "‚Ä¢ ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä ŸÑÿ£Ÿä ÿßÿ≥ÿ™ŸÅÿ≥ÿßÿ±\n\n"
            "ÿßÿ®ÿØÿ£ ÿßŸÑÿ¢ŸÜ ÿ®ÿßŸÑÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ 'üöÄ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÑŸÑÿ¨ÿßŸÖÿπÿ©'!"
        )

    async def _broadcast_quote(self, context: ContextTypes.DEFAULT_TYPE):
        try:
            quote = await self.grade_analytics.get_daily_quote()
            if not quote:
                logger.warning("No quote available for broadcast.")
                return
            # Format quote in two languages
            quote_text = await self.grade_analytics.format_quote_dual_language(quote)
            for user in self.user_storage.get_all_users():
                telegram_id = user.get("telegram_id")
                if telegram_id:
                    try:
                        await context.bot.send_message(chat_id=telegram_id, text=quote_text, parse_mode=ParseMode.MARKDOWN)
                    except Exception as e:
                        logger.warning(f"Failed to send quote to {telegram_id}: {e}")
        except Exception as e:
            logger.error(f"Error in _broadcast_quote: {e}")

    async def _refresh_keyboard(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Refresh keyboard based on user registration status"""
        try:
            user = self.user_storage.get_user(update.effective_user.id)
            if user:
                await update.message.reply_text(
                    "‚úÖ ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ£ÿ≤ÿ±ÿßÿ± ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿßŸÑŸÖÿ≥ÿ¨ŸÑŸäŸÜ.",
                    reply_markup=get_main_keyboard()
                )
            else:
                await update.message.reply_text(
                    "‚ùå ÿ£ŸÜÿ™ ÿ∫Ÿäÿ± ŸÖÿ≥ÿ¨ŸÑ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ£ŸàŸÑÿßŸã.",
                    reply_markup=get_unregistered_keyboard()
                )
        except Exception as e:
            logger.error(f"[ALERT] Error in _refresh_keyboard: {e}", exc_info=True)
            admin_id = CONFIG.get("ADMIN_ID")
            admin_username = CONFIG.get("ADMIN_USERNAME", "@admin")
            if admin_id:
                try:
                    await self.app.bot.send_message(chat_id=admin_id, text=f"[REFRESH ERROR] User: {getattr(update.effective_user, 'id', None)}\nError: {e}")
                except Exception:
                    pass
            await update.message.reply_text(f"‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ£ÿ≤ÿ±ÿßÿ±. ÿ•ÿ∞ÿß ÿßÿ≥ÿ™ŸÖÿ±ÿ™ ÿßŸÑŸÖÿ¥ŸÉŸÑÿ©ÿå ŸÑÿß ÿ™ÿ™ÿ±ÿØÿØ ŸÅŸä ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑŸÖÿ∑Ÿàÿ± {admin_username}.", reply_markup=get_main_keyboard())

    async def _force_logout_user(self, telegram_id: int, update: Update):
        """Force logout user due to invalid token"""
        logger.info(f"üîÑ Forcing logout for user {telegram_id} due to invalid token")
        
        # End user session
        if hasattr(security_manager, 'session_manager'):
            security_manager.session_manager.invalidate_session(telegram_id)
        
        # Clear user token
        if hasattr(self.user_storage, 'clear_user_token'):
            # For PostgreSQL storage
            self.user_storage.clear_user_token(telegram_id)
        else:
            # For file storage
            user = self.user_storage.get_user(telegram_id)
            if user:
                user["token"] = None
                user["is_active"] = False
                if hasattr(self.user_storage, '_save_users'):
                    self.user_storage._save_users()
        
        # Notify user
        await update.message.reply_text(
            "‚è∞ ÿßŸÜÿ™Ÿáÿ™ ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑÿ¨ŸÑÿ≥ÿ©\n\nÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿÆÿ±Ÿàÿ¨ ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã ŸÑÿ≠ŸÖÿßŸäÿ© ÿ≠ÿ≥ÿßÿ®ŸÉ. Ÿäÿ±ÿ¨Ÿâ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÖŸÜ ÿÆŸÑÿßŸÑ ÿ≤ÿ± 'üöÄ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÑŸÑÿ¨ÿßŸÖÿπÿ©'.",
            reply_markup=get_unregistered_keyboard()
        )

    async def _logout_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        telegram_id = update.effective_user.id
        # End user session
        if hasattr(security_manager, 'session_manager'):
            security_manager.session_manager.invalidate_session(telegram_id)
        # Remove user token and mark as inactive
        user = self.user_storage.get_user(telegram_id)
        if user:
            if hasattr(self.user_storage, 'clear_user_token'):
                # For PostgreSQL storage
                self.user_storage.clear_user_token(telegram_id)
            else:
                # For file storage
                user["token"] = None
                user["is_active"] = False
                if hasattr(self.user_storage, '_save_users'):
                    self.user_storage._save_users()
        await update.message.reply_text(
            "‚úÖ ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿÆÿ±Ÿàÿ¨ ÿ®ŸÜÿ¨ÿßÿ≠. ŸäŸÖŸÉŸÜŸÉ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÅŸä ÿ£Ÿä ŸàŸÇÿ™.",
            reply_markup=get_unregistered_keyboard()
        )

    async def _settings_callback_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        await query.answer()
        user_id = update.effective_user.id
        user = self.user_storage.get_user_by_telegram_id(user_id)
        
        if query.data == "toggle_translation":
            if not user:
                await query.edit_message_text("‚ùóÔ∏è Ÿäÿ¨ÿ® ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ£ŸàŸÑÿßŸã.")
                return
            # Toggle do_trans
            new_value = not user.get("do_trans", False)
            self.user_storage.update_user(user["username"], {"do_trans": new_value})
            # Refresh keyboard
            from utils.keyboards import get_settings_main_keyboard
            keyboard = get_settings_main_keyboard(translation_enabled=new_value)
            status = "ŸÖŸÅÿπŸÑÿ©" if new_value else "ŸÖÿπÿ∑ŸÑÿ©"
            await query.edit_message_text(
                f"üåê ÿ™ŸÖ {'ÿ™ŸÅÿπŸäŸÑ' if new_value else 'ÿ™ÿπÿ∑ŸäŸÑ'} ÿ™ÿ±ÿ¨ŸÖÿ© ÿßŸÑÿßŸÇÿ™ÿ®ÿßÿ≥ÿßÿ™ ŸÑŸÑÿπÿ±ÿ®Ÿäÿ©.\n\nÿßŸÑÿ≠ÿßŸÑÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©: {status}",
                reply_markup=keyboard
            )
            return
            
        elif query.data == "delete_user_data":
            if not user:
                await query.edit_message_text("‚ùóÔ∏è Ÿäÿ¨ÿ® ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ£ŸàŸÑÿßŸã.")
                return
            # Show confirmation for data deletion
            await query.edit_message_text(
                "üóëÔ∏è **ÿ≠ÿ∞ŸÅ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ¥ÿÆÿµŸäÿ©**\n\n"
                "‚ö†Ô∏è **ÿ™ÿ≠ÿ∞Ÿäÿ±**: Ÿáÿ∞ÿß ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ° ÿ≥Ÿäÿ≠ÿ∞ŸÅ:\n"
                "‚Ä¢ ÿ¨ŸÖŸäÿπ ÿ®ŸäÿßŸÜÿßÿ™ŸÉ ÿßŸÑŸÖÿÆÿ≤ŸÜÿ©\n"
                "‚Ä¢ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿßŸÑŸÖÿ¥ŸÅÿ±ÿ©\n"
                "‚Ä¢ ÿ•ÿπÿØÿßÿØÿßÿ™ŸÉ ÿßŸÑÿ¥ÿÆÿµŸäÿ©\n"
                "‚Ä¢ ÿ≥ÿ¨ŸÑ ÿßŸÑÿØÿ±ÿ¨ÿßÿ™\n\n"
                "‚ùå **ŸÑÿß ŸäŸÖŸÉŸÜ ÿßŸÑÿ™ÿ±ÿßÿ¨ÿπ ÿπŸÜ Ÿáÿ∞ÿß ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ°**\n\n"
                "ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿ®ŸäÿßŸÜÿßÿ™ŸÉÿü",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("‚úÖ ŸÜÿπŸÖÿå ÿßÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿ®ŸäÿßŸÜÿßÿ™Ÿä", callback_data="confirm_delete_data")],
                    [InlineKeyboardButton("‚ùå ÿ•ŸÑÿ∫ÿßÿ°", callback_data="cancel_delete_data")]
                ])
            )
            return
            
        elif query.data == "confirm_delete_data":
            if not user:
                await query.edit_message_text("‚ùóÔ∏è Ÿäÿ¨ÿ® ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ£ŸàŸÑÿßŸã.")
                return
            # Delete user data
            try:
                # Delete user from storage
                self.user_storage.delete_user(user["username"])
                # Delete grades
                self.grade_storage.delete_user_grades(user["username"])
                await query.edit_message_text(
                    "‚úÖ ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿ®ŸäÿßŸÜÿßÿ™ŸÉ ÿ®ŸÜÿ¨ÿßÿ≠.\n\n"
                    "ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿÆÿ±Ÿàÿ¨ŸÉ ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã. ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ÿ•ÿ∞ÿß ÿ£ÿ±ÿØÿ™.",
                    reply_markup=get_unregistered_keyboard()
                )
            except Exception as e:
                await query.edit_message_text(
                    f"‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ÿ∞ŸÅ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™: {str(e)}\n\n"
                    "Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ÿ£Ÿà ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä."
                )
            return
            
        elif query.data == "cancel_delete_data":
            # Return to privacy settings
            await query.edit_message_text(
                "ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿ≠ÿ∞ŸÅ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™.",
                reply_markup=get_privacy_settings_keyboard()
            )
            return
            
        elif query.data == "toggle_show_profile":
            if not user:
                await query.edit_message_text("‚ùóÔ∏è Ÿäÿ¨ÿ® ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ£ŸàŸÑÿßŸã.")
                return
            # Toggle profile visibility (placeholder for future implementation)
            await query.edit_message_text(
                "üëÅÔ∏è **ÿπÿ±ÿ∂ ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ¥ÿÆÿµŸäÿ©**\n\n"
                "Ÿáÿ∞Ÿá ÿßŸÑŸÖŸäÿ≤ÿ© ŸÇŸäÿØ ÿßŸÑÿ™ÿ∑ŸàŸäÿ±.\n\n"
                "ÿ≥ÿ™ÿ™ŸÖŸÉŸÜ ŸÇÿ±Ÿäÿ®ÿßŸã ŸÖŸÜ ÿßŸÑÿ™ÿ≠ŸÉŸÖ ŸÅŸä ÿπÿ±ÿ∂ ŸÖÿπŸÑŸàŸÖÿßÿ™ŸÉ ÿßŸÑÿ¥ÿÆÿµŸäÿ© ŸÑŸÑÿ¢ÿÆÿ±ŸäŸÜ.",
                reply_markup=get_privacy_settings_keyboard()
            )
            return
            
        elif query.data == "toggle_share_stats":
            if not user:
                await query.edit_message_text("‚ùóÔ∏è Ÿäÿ¨ÿ® ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ£ŸàŸÑÿßŸã.")
                return
            # Toggle stats sharing (placeholder for future implementation)
            await query.edit_message_text(
                "üìä **ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™**\n\n"
                "Ÿáÿ∞Ÿá ÿßŸÑŸÖŸäÿ≤ÿ© ŸÇŸäÿØ ÿßŸÑÿ™ÿ∑ŸàŸäÿ±.\n\n"
                "ÿ≥ÿ™ÿ™ŸÖŸÉŸÜ ŸÇÿ±Ÿäÿ®ÿßŸã ŸÖŸÜ ÿßŸÑÿ™ÿ≠ŸÉŸÖ ŸÅŸä ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ŸÉ ŸÖÿπ ÿßŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ŸÑÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿÆÿØŸÖÿ©.",
                reply_markup=get_privacy_settings_keyboard()
            )
            return
            
        elif query.data == "data_retention":
            if not user:
                await query.edit_message_text("‚ùóÔ∏è Ÿäÿ¨ÿ® ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ£ŸàŸÑÿßŸã.")
                return
            # Data retention settings (placeholder for future implementation)
            await query.edit_message_text(
                "üìÖ **ŸÅÿ™ÿ±ÿ© ÿßŸÑÿßÿ≠ÿ™ŸÅÿßÿ∏ ÿ®ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™**\n\n"
                "Ÿáÿ∞Ÿá ÿßŸÑŸÖŸäÿ≤ÿ© ŸÇŸäÿØ ÿßŸÑÿ™ÿ∑ŸàŸäÿ±.\n\n"
                "ÿ≥ÿ™ÿ™ŸÖŸÉŸÜ ŸÇÿ±Ÿäÿ®ÿßŸã ŸÖŸÜ ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖÿØÿ© ÿßŸÑÿ™Ÿä ŸÜÿ≠ÿ™ŸÅÿ∏ ŸÅŸäŸáÿß ÿ®ÿ®ŸäÿßŸÜÿßÿ™ŸÉ.",
                reply_markup=get_privacy_settings_keyboard()
            )
            return
            
        elif query.data == "back_to_settings":
            # Return to main settings
            from utils.keyboards import get_settings_main_keyboard
            keyboard = get_settings_main_keyboard(translation_enabled=user.get("do_trans", False) if user else False)
            await query.edit_message_text(
                "ÿ™ŸÖÿ™ ÿßŸÑÿπŸàÿØÿ© ÿ•ŸÑŸâ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©.",
                reply_markup=keyboard
            )
            return
            
        elif query.data == "back_to_main":
            await query.edit_message_text(
                "ÿ™ŸÖÿ™ ÿßŸÑÿπŸàÿØÿ© ÿ•ŸÑŸâ ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©.\n\n"
                "ŸÜÿ≠ŸÜ ŸÜŸÇÿØÿ± ÿ´ŸÇÿ™ŸÉ ŸàŸÜÿ≥ÿπŸâ ÿØÿßÿ¶ŸÖÿßŸã ŸÑŸÑÿ¥ŸÅÿßŸÅŸäÿ© ŸÅŸä ŸÉŸÑ ŸÖÿß Ÿäÿ™ÿπŸÑŸÇ ÿ®ÿ®ŸäÿßŸÜÿßÿ™ŸÉ."
            )
        elif query.data == "cancel_action":
            is_registered = self.user_storage.is_user_registered(update.effective_user.id)
            keyboard = get_main_keyboard() if is_registered else get_unregistered_keyboard()
            await query.edit_message_text(
                "‚úÖ ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿπŸÖŸÑŸäÿ©. ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ®ÿØÿ° ŸÖŸÜ ÿ¨ÿØŸäÿØ ÿ£Ÿà ÿßÿÆÿ™Ÿäÿßÿ± ÿ•ÿ¨ÿ±ÿßÿ° ÿ¢ÿÆÿ±.",
            )
            await update.effective_chat.send_message(
                "ÿ™ŸÖÿ™ ÿ•ÿπÿßÿØÿ™ŸÉ ŸÑŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©.",
                reply_markup=keyboard
            )

    async def _gpa_calc_fallback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await update.message.reply_text("ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿπŸÖŸÑŸäÿ©. ÿ£ÿ±ÿ≥ŸÑ /start ŸÑŸÑÿ®ÿØÿ° ŸÖŸÜ ÿ¨ÿØŸäÿØ.")
        return ConversationHandler.END

    async def _gpa_calc_start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        context.user_data['gpa_calc'] = {'courses': [], 'current': 0, 'count': 0}
        await update.message.reply_text(
            "ŸÉŸÖ ÿπÿØÿØ ÿßŸÑŸÖŸÇÿ±ÿ±ÿßÿ™ ÿßŸÑÿ™Ÿä ÿ™ÿ±ŸäÿØ ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÖÿπÿØŸÑ ÿßŸÑÿ™ÿ±ÿßŸÉŸÖŸä ŸÑŸáÿßÿü (ÿ£ÿØÿÆŸÑ ÿ±ŸÇŸÖÿßŸã ÿ®ŸäŸÜ 1 Ÿà10)",
            reply_markup=ReplyKeyboardMarkup([["‚ùå ÿ•ŸÑÿ∫ÿßÿ°"]], resize_keyboard=True, one_time_keyboard=True)
        )
        return ASK_GPA_COURSE_COUNT

    async def _gpa_ask_course_count(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            count = int(update.message.text.strip())
            if not (1 <= count <= 10):
                raise ValueError
            context.user_data['gpa_calc']['count'] = count
            context.user_data['gpa_calc']['current'] = 1
            await update.message.reply_text(
                f"ÿ£ÿØÿÆŸÑ ÿßŸÑŸÜÿ≥ÿ®ÿ© ÿßŸÑŸÖÿ¶ŸàŸäÿ© ŸÑŸÑŸÖŸÇÿ±ÿ± ÿ±ŸÇŸÖ 1 (ŸÖÿ´ÿßŸÑ: 85)",
                reply_markup=ReplyKeyboardMarkup([["‚ùå ÿ•ŸÑÿ∫ÿßÿ°"]], resize_keyboard=True, one_time_keyboard=True)
            )
            return ASK_GPA_PERCENTAGE
        except Exception:
            await update.message.reply_text("‚ùå ÿ£ÿØÿÆŸÑ ÿ±ŸÇŸÖÿßŸã ÿµÿ≠Ÿäÿ≠ÿßŸã ÿ®ŸäŸÜ 1 Ÿà10.")
            return ASK_GPA_COURSE_COUNT

    async def _gpa_ask_percentage(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            # Try to extract integer from input
            text = update.message.text.strip()
            # Extract first number (integer or float) from the string
            import re
            match = re.search(r"\d+(?:\.\d+)?", text)
            if not match:
                raise ValueError("No digits found")
            percent = int(float(match.group(0)))
            if not (0 <= percent <= 100):
                raise ValueError("Out of range")
            # Check if percentage is below 30 (0 earned points)
            if percent < 30:
                await update.message.reply_text(f"‚ö†Ô∏è ÿßŸÑŸÜÿ≥ÿ®ÿ© ÿßŸÑŸÖÿ¶ŸàŸäÿ© {percent}% ÿ£ŸÇŸÑ ŸÖŸÜ 30%ÿå ÿ≥ÿ™ŸÉŸàŸÜ ÿßŸÑŸÜŸÇÿßÿ∑ ÿßŸÑŸÖŸÉÿ™ÿ≥ÿ®ÿ© 0.")
            context.user_data['gpa_calc']['courses'].append({'percentage': percent})
            # Ask for ECTS for this course
            current = context.user_data['gpa_calc']['current']
            await update.message.reply_text(
                f"ÿ£ÿØÿÆŸÑ ÿπÿØÿØ ŸÜŸÇÿßÿ∑ ECTS ÿßŸÑŸÖÿÆÿµÿµÿ© ŸÑŸÑŸÖŸÇÿ±ÿ± ÿ±ŸÇŸÖ {current} (ŸÖÿ´ÿßŸÑ: 4)",
                reply_markup=ReplyKeyboardMarkup([["‚ùå ÿ•ŸÑÿ∫ÿßÿ°"]], resize_keyboard=True, one_time_keyboard=True)
            )
            return ASK_GPA_ECTS
        except Exception:
            await update.message.reply_text("‚ùå ÿ£ÿØÿÆŸÑ ŸÜÿ≥ÿ®ÿ© ŸÖÿ¶ŸàŸäÿ© ÿµÿ≠Ÿäÿ≠ÿ© ÿ®ŸäŸÜ 0 Ÿà100.")
            return ASK_GPA_PERCENTAGE

    async def _gpa_ask_ects(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            ects = float(update.message.text.strip())
            if not (0.5 <= ects <= 20):
                raise ValueError
            current = context.user_data['gpa_calc']['current']
            context.user_data['gpa_calc']['courses'][-1]['ects'] = ects
            if current >= context.user_data['gpa_calc']['count']:
                # Calculate GPA
                return await self._gpa_calc_show_result(update, context)
            else:
                context.user_data['gpa_calc']['current'] += 1
                await update.message.reply_text(
                    f"ÿ£ÿØÿÆŸÑ ÿßŸÑŸÜÿ≥ÿ®ÿ© ÿßŸÑŸÖÿ¶ŸàŸäÿ© ŸÑŸÑŸÖŸÇÿ±ÿ± ÿ±ŸÇŸÖ {context.user_data['gpa_calc']['current']} (ÿØŸàŸÜ ÿ•ÿ¥ÿßÿ±ÿ© %ÿå ŸÖÿ´ÿßŸÑ: 85)",
                    reply_markup=ReplyKeyboardMarkup([["‚ùå ÿ•ŸÑÿ∫ÿßÿ°"]], resize_keyboard=True, one_time_keyboard=True)
                )
                return ASK_GPA_PERCENTAGE
        except Exception:
            await update.message.reply_text("‚ùå ÿ£ÿØÿÆŸÑ ÿπÿØÿØ ŸÜŸÇÿßÿ∑ ECTS ÿµÿ≠Ÿäÿ≠ (ÿπÿßÿØÿ© ÿ®ŸäŸÜ 0.5 Ÿà20)")
            return ASK_GPA_ECTS

    async def _gpa_calc_show_result(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        from utils.analytics import GradeAnalytics
        analytics = GradeAnalytics(self.user_storage)
        # Build grades list in the same format as analytics expects
        grades = []
        for c in context.user_data['gpa_calc']['courses']:
            grades.append({'total': str(c['percentage']), 'ects': c['ects']})
        gpa = analytics._calculate_gpa(grades)
        if gpa is not None:
            # Format to exactly 3 digits from left to right (e.g., 3.15, 2.5, 4.0)
            # Remove trailing zeros and decimal point
            gpa_str = f"{gpa:.2f}"
            # Remove trailing zeros (including those followed by decimal point)
            while gpa_str.endswith('0') and '.' in gpa_str:
                gpa_str = gpa_str[:-1]
            # Remove trailing decimal point
            if gpa_str.endswith('.'):
                gpa_str = gpa_str[:-1]
            if gpa_str == '':
                gpa_str = '0'
        else:
            gpa_str = "-"
        await update.message.reply_text(f"‚úÖ ÿßŸÑŸÖÿπÿØŸÑ ÿßŸÑÿ™ÿ±ÿßŸÉŸÖŸä (GPA) ŸÑŸÑŸÖŸÇÿ±ÿ±ÿßÿ™ ÿßŸÑŸÖÿØÿÆŸÑÿ©: {gpa_str}", reply_markup=get_main_keyboard())
        context.user_data.pop('gpa_calc', None)
        return ConversationHandler.END

    async def _cancel_gpa_calc(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Cancel handler for custom GPA calculator flow."""
        context.user_data.pop('gpa_calc', None)
        is_registered = self.user_storage.is_user_registered(update.effective_user.id)
        keyboard = get_main_keyboard() if is_registered else get_unregistered_keyboard()
        await update.message.reply_text(
            "‚ùå ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿπŸÖŸÑŸäÿ© ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÖÿπÿØŸÑ. ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ®ÿØÿ° ŸÖŸÜ ÿ¨ÿØŸäÿØ ÿ£Ÿà ÿßÿÆÿ™Ÿäÿßÿ± ÿ•ÿ¨ÿ±ÿßÿ° ÿ¢ÿÆÿ±.",
            reply_markup=keyboard
        )
        return ConversationHandler.END

    async def _session_management_start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user = self.user_storage.get_user(update.effective_user.id)
        if not user:
            await update.message.reply_text("‚ùóÔ∏è Ÿäÿ¨ÿ® ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ£ŸàŸÑÿßŸã.", reply_markup=get_unregistered_keyboard())
            return ConversationHandler.END
        session_type = "ÿØÿßÿ¶ŸÖÿ©" if user.get("password_stored") else "ŸÖÿ§ŸÇÿ™ÿ©"
        await update.message.reply_text(
            f"üîë ÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿ¨ŸÑÿ≥ÿ©/ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±\n\n"
            f"ŸÜŸàÿπ ÿßŸÑÿ¨ŸÑÿ≥ÿ© ÿßŸÑÿ≠ÿßŸÑŸä: {session_type}\n"
            "ŸäŸÖŸÉŸÜŸÉ ŸáŸÜÿß ÿ™ÿ∫ŸäŸäÿ± ŸÜŸàÿπ ÿßŸÑÿ¨ŸÑÿ≥ÿ© ÿ£Ÿà ÿ≠ÿ∞ŸÅ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿßŸÑŸÖÿÆÿ≤ŸÜÿ©.\n\n"
            "‚Ä¢ ŸÑŸÑÿßŸÜÿ™ŸÇÿßŸÑ ÿ•ŸÑŸâ ÿ¨ŸÑÿ≥ÿ© ŸÖÿ§ŸÇÿ™ÿ© (ÿ®ÿØŸàŸÜ ÿ™ÿÆÿ≤ŸäŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±)ÿå ÿ£ÿ±ÿ≥ŸÑ: 'ÿ™ÿ≠ŸàŸäŸÑ ÿ•ŸÑŸâ ŸÖÿ§ŸÇÿ™ÿ©'\n"
            "‚Ä¢ ŸÑŸÑÿßŸÜÿ™ŸÇÿßŸÑ ÿ•ŸÑŸâ ÿ¨ŸÑÿ≥ÿ© ÿØÿßÿ¶ŸÖÿ© (ÿ™ÿÆÿ≤ŸäŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ŸÖÿ¥ŸÅÿ±)ÿå ÿ£ÿ±ÿ≥ŸÑ: 'ÿ™ÿ≠ŸàŸäŸÑ ÿ•ŸÑŸâ ÿØÿßÿ¶ŸÖÿ©'\n"
            "‚Ä¢ ŸÑÿ≠ÿ∞ŸÅ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿßŸÑŸÖÿÆÿ≤ŸÜÿ©ÿå ÿ£ÿ±ÿ≥ŸÑ: 'ÿ≠ÿ∞ŸÅ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±'\n\n"
            "üîô ÿßŸÑÿπŸàÿØÿ©"
        )
        return ASK_SESSION_MANAGEMENT

    async def _handle_session_management(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        text = update.message.text.strip()
        user_id = update.effective_user.id
        user = self.user_storage.get_user(user_id)
        if not user:
            await update.message.reply_text("‚ùóÔ∏è Ÿäÿ¨ÿ® ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ£ŸàŸÑÿßŸã.", reply_markup=get_unregistered_keyboard())
            return ConversationHandler.END
        if text == "ÿ™ÿ≠ŸàŸäŸÑ ÿ•ŸÑŸâ ŸÖÿ§ŸÇÿ™ÿ©":
            self.user_storage.save_user(
                user_id,
                user["username"],
                user["token"],
                user,
                encrypted_password="",
                password_stored=False,
                password_consent_given=False
            )
            await update.message.reply_text("‚úÖ ÿ™ŸÖ ÿßŸÑÿ™ÿ≠ŸàŸäŸÑ ÿ•ŸÑŸâ ÿ¨ŸÑÿ≥ÿ© ŸÖÿ§ŸÇÿ™ÿ©. ŸÑŸÜ Ÿäÿ™ŸÖ ÿ™ÿÆÿ≤ŸäŸÜ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿ®ÿπÿØ ÿßŸÑÿ¢ŸÜ.", reply_markup=get_main_keyboard())
            return ConversationHandler.END
        elif text == "ÿ™ÿ≠ŸàŸäŸÑ ÿ•ŸÑŸâ ÿØÿßÿ¶ŸÖÿ©":
            await update.message.reply_text("Ÿäÿ±ÿ¨Ÿâ ÿ•ÿπÿßÿØÿ© ÿ•ÿØÿÆÿßŸÑ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ŸÑÿ™ÿÆÿ≤ŸäŸÜŸáÿß ÿ®ÿ¥ŸÉŸÑ ŸÖÿ¥ŸÅÿ±:")
            context.user_data["session_upgrade"] = True
            return ASK_PASSWORD
        elif text == "ÿ≠ÿ∞ŸÅ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±":
            self.user_storage.save_user(
                user_id,
                user["username"],
                user["token"],
                user,
                encrypted_password="",
                password_stored=False,
                password_consent_given=False
            )
            await update.message.reply_text("‚úÖ ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿßŸÑŸÖÿÆÿ≤ŸÜÿ©.", reply_markup=get_main_keyboard())
            return ConversationHandler.END
        elif text == "üîô ÿßŸÑÿπŸàÿØÿ©":
            await self._return_to_main(update, context)
            return ConversationHandler.END
        else:
            await update.message.reply_text("‚ùå Ÿäÿ±ÿ¨Ÿâ ÿßÿÆÿ™Ÿäÿßÿ± ÿ£Ÿà ŸÉÿ™ÿßÿ®ÿ© ÿ£ÿ≠ÿØ ÿßŸÑÿÆŸäÿßÿ±ÿßÿ™ ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ© ŸÅŸÇÿ∑.")
            return ASK_SESSION_MANAGEMENT

    async def _older_terms_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle the 'older terms' button: show list of all terms, prompt for number, then fetch grades for selected term."""
        telegram_id = update.effective_user.id
        user = self.user_storage.get_user(telegram_id)
        if not user:
            await update.message.reply_text("‚ùóÔ∏è Ÿäÿ¨ÿ® ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ£ŸàŸÑÿßŸã.", reply_markup=get_unregistered_keyboard())
            return
        token = user.get("session_token")
        if not token:
            await update.message.reply_text("‚ùóÔ∏è Ÿäÿ¨ÿ® ÿ•ÿπÿßÿØÿ© ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ.", reply_markup=get_unregistered_keyboard())
            return
        # Fetch all terms
        homepage_data = await self.university_api.get_homepage_data(token)
        if not homepage_data:
            await update.message.reply_text("‚ùå ÿ™ÿπÿ∞ÿ± ÿ¨ŸÑÿ® ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÅÿµŸàŸÑ. ÿ≠ÿßŸàŸÑ ŸÑÿßÿ≠ŸÇÿßŸã.", reply_markup=get_main_keyboard())
            return
        terms = self.university_api.extract_terms_from_homepage(homepage_data)
        if not terms or len(terms) < 1:
            await update.message.reply_text("‚ùå ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÅÿµŸàŸÑ ŸÖÿ™ÿßÿ≠ÿ©.", reply_markup=get_main_keyboard())
            return
        # Show numbered list (skip first two: current, previous)
        all_terms = terms
        context.user_data['older_terms_list'] = all_terms
        msg = "ÿßÿÆÿ™ÿ± ÿ±ŸÇŸÖ ÿßŸÑŸÅÿµŸÑ ÿßŸÑÿ∞Ÿä ÿ™ÿ±ŸäÿØ ÿπÿ±ÿ∂ ÿØÿ±ÿ¨ÿßÿ™Ÿá:\n\n"
        for idx, (term_name, _) in enumerate(all_terms, 1):
            msg += f"{idx}. {term_name}\n"
        msg += "\nÿ£ÿØÿÆŸÑ ÿ±ŸÇŸÖ ÿßŸÑŸÅÿµŸÑ ÿßŸÑŸÖÿ∑ŸÑŸàÿ® (ŸÖÿ´ÿßŸÑ: 1):"
        await update.message.reply_text(msg, reply_markup=remove_keyboard())
        context.user_data['last_action'] = 'older_terms'
        return ASK_OLDER_TERM_NUMBER

    async def _ask_older_term_number(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        telegram_id = update.effective_user.id
        user = self.user_storage.get_user(telegram_id)
        if not user:
            await update.message.reply_text("‚ùóÔ∏è Ÿäÿ¨ÿ® ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ£ŸàŸÑÿßŸã.", reply_markup=get_unregistered_keyboard())
            return ConversationHandler.END
        token = user.get("session_token")
        if not token:
            await update.message.reply_text("‚ùóÔ∏è Ÿäÿ¨ÿ® ÿ•ÿπÿßÿØÿ© ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ.", reply_markup=get_unregistered_keyboard())
            return ConversationHandler.END
        all_terms = context.user_data.get('older_terms_list')
        if not all_terms:
            await update.message.reply_text("‚ùå ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÅÿµŸàŸÑ ŸÖÿ™ÿßÿ≠ÿ©.", reply_markup=get_main_keyboard())
            return ConversationHandler.END
        try:
            number = int(update.message.text.strip())
        except Exception:
            await update.message.reply_text("‚ùå ÿ£ÿØÿÆŸÑ ÿ±ŸÇŸÖ ÿµÿ≠Ÿäÿ≠ ŸÑŸÑŸÅÿµŸÑ.")
            return ASK_OLDER_TERM_NUMBER
        if not (1 <= number <= len(all_terms)):
            await update.message.reply_text(f"‚ùå ÿßÿÆÿ™ÿ± ÿ±ŸÇŸÖ ÿ®ŸäŸÜ 1 Ÿà {len(all_terms)}.")
            return ASK_OLDER_TERM_NUMBER
        term_name, term_id = all_terms[number-1]
        # Fetch grades for selected term
        grades = await self.university_api.get_term_grades(token, term_id)
        if not grades:
            await update.message.reply_text(f"‚ùå ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿØÿ±ÿ¨ÿßÿ™ ŸÖÿ™ÿßÿ≠ÿ© ŸÑŸÑŸÅÿµŸÑ: {term_name}", reply_markup=get_main_keyboard())
            return ConversationHandler.END
        # Add term info to grades
        for grade in grades:
            grade['term_name'] = term_name
            grade['term_id'] = term_id
        # Save grades to storage
        self.grade_storage.store_grades(user.get('username'), grades)
        # Format and send grades for the selected term
        formatted_message = await self.grade_analytics.format_old_grades_with_analysis(telegram_id, grades)
        if len(formatted_message) > 4096:
            for i in range(0, len(formatted_message), 4096):
                await update.message.reply_text(formatted_message[i:i+4096], reply_markup=get_main_keyboard())
        else:
            await update.message.reply_text(formatted_message, reply_markup=get_main_keyboard())
        return ConversationHandler.END

    async def _download_my_info_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        telegram_id = update.effective_user.id
        user = self.user_storage.get_user(telegram_id)
        if not user:
            await update.message.reply_text("‚ùóÔ∏è Ÿäÿ¨ÿ® ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ£ŸàŸÑÿßŸã.", reply_markup=get_unregistered_keyboard())
            return
        # Remove sensitive/session fields if needed
        user_info = dict(user)
        user_info.pop("session_token", None)
        # Convert to JSON
        json_str = json.dumps(user_info, ensure_ascii=False, indent=2)
        # Inform the user about privacy
        await update.message.reply_text(
            "Ÿáÿ∞Ÿá ŸÉŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ™Ÿä ŸäÿÆÿ≤ŸÜŸáÿß ÿßŸÑÿ®Ÿàÿ™ ÿπŸÜŸÉ. ŸÑÿß ÿ£ÿ≠ÿØ Ÿäÿ∑ŸÑÿπ ÿπŸÑŸäŸáÿß ÿ•ŸÑÿß ÿπŸÜÿØ ÿ∑ŸÑÿ®ŸÉ ÿ∞ŸÑŸÉ ÿ®ÿ¥ŸÉŸÑ ŸÖÿ®ÿßÿ¥ÿ±ÿå ŸàŸäÿ™ŸÖ ÿ¨ŸÑÿ®Ÿáÿß ŸÅŸÇÿ∑ ÿπŸÜÿØ ÿ∑ŸÑÿ®ŸÉ."
        )
        # Send as file
        await update.message.reply_document(
            document=bytes(json_str, encoding="utf-8"),
            filename="my_information.json",
            caption="üì• Ÿáÿ∞Ÿá ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÖÿÆÿ≤ŸÜÿ© ÿπŸÜŸÉ ŸÅŸä ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™."
        )

    async def _silent_update_all_users_grades(self):
        """
        Refresh grades for all users and save them to storage, but do NOT send any notifications.
        Returns the number of users whose grades were refreshed.
        """
        users = self.user_storage.get_all_users()
        logger.info(f"üîï Silent update: Found {len(users)} users in database")
        if not users:
            logger.warning("‚ö†Ô∏è No users found in database for silent update")
            return 0
        updated_count = 0
        semaphore = asyncio.Semaphore(CONFIG.get('MAX_CONCURRENT_REQUESTS', 5))
        tasks = []
        results = []

        async def refresh_user(user):
            async with semaphore:
                try:
                    telegram_id = user.get("telegram_id")
                    username = user.get("username")
                    username_unique = user.get("username_unique")
                    # Fallback: use username if username_unique is missing
                    storage_username = username_unique or username
                    if not storage_username:
                        logger.error(f"[ALERT] Cannot store grades: missing username and username_unique for user with telegram_id={telegram_id}")
                        return False
                    token = user.get("session_token")
                    lock = self._get_user_lock(storage_username)
                    async with lock:
                        if not token:
                            return False
                        # Test token validity
                        if not await self.university_api.test_token(token):
                            return False
                        user_data = await self.university_api.get_user_data(token)
                        if not user_data or "grades" not in user_data:
                            return False
                        new_grades = user_data.get("grades", [])
                        self.grade_storage.store_grades(storage_username, new_grades)
                        return True
                except Exception as e:
                    logger.error(f"‚ùå Error in silent grade refresh for user {user.get('username', 'Unknown')}: {e}", exc_info=True)
                    return False

        for user in users:
            tasks.append(asyncio.create_task(refresh_user(user)))
        if tasks:
            results = await asyncio.gather(*tasks, return_exceptions=True)
            updated_count = sum(1 for r in results if r is True)
        logger.info(f"üîï Silent update completed: {updated_count}/{len(users)} users refreshed")
        return updated_count